简约的浏览器结构图：

**用户界面 → 浏览器引擎 →渲染引擎**

补课链接：

[https://www.bilibili.com/video/BV1x54y1B7RE?t=983.4](https://www.bilibili.com/video/BV1x54y1B7RE?t=983.4)

渲染引擎负责渲染用户请求的页面内容，浏览器引擎作为用户界面喝渲染引擎中间传递数据的**媒介**

渲染引擎（浏览器的内核）还包括一些小的模块，有网络模块，JS解释器

![](https://cdn.nlark.com/yuque/0/2023/png/32650608/1679020786730-b9592371-9b1d-4209-ba23-25b2dd923f62.png)

而浏览器作为运行在操作系统上的一个应用程序，肯定也是至少由一个进程启动的

![](https://cdn.nlark.com/yuque/0/2023/png/32650608/1679020805622-d7e74b28-9d12-458a-8ddd-68dd4f44ca55.png)

启动程序时候的过程大致是这个样子的，当我们启动一个程序时，系统就会创建一个进程来执行任务代码，同时会为该进程分配内存空间 ，该应用程序的状态都保存在该内存空间，应用关闭时，该应用就会被回收

![](https://cdn.nlark.com/yuque/0/2023/png/32650608/1679020811269-f31f6c0e-c348-464d-b561-0276b1ad80d4.png)

进程可以使用更多的进程来执行任务，由于每个进程分配的内存空间是独立的，如果我们在两个进程之间需要进行数据通信，则需要通过进程间通信管道IPC来进行数据通信(多进程主要为了避免程序卡顿)

进程可以将任务分成更多细小的任务，然后通过创建不同的线程并行执行不同的任务，同一个进程下的线程是可以直接共享数据的

![](https://cdn.nlark.com/yuque/0/2023/png/32650608/1679020818617-3e1709b3-054e-4464-a973-0802d174c765.png)

# **多进程结构的浏览器**

![](https://cdn.nlark.com/yuque/0/2023/png/32650608/1679020824196-f193ad05-3812-4d14-8006-62d5a7a3093f.png)

浏览器进程： 控制标签页之外的用户界面

GPU进程：负责浏览器页面的渲染

缓存进程： -

网络进程：发起接受网络请求

插件进程：控制网站使用的所有插件

渲染器进程：控制标签页内的所有内容

## **输入网址或者key words之后**

当我们在浏览器地址栏输入网址或者关键词之后，chrome浏览器的UI线程先去判断你输入的是网址(进行dns解析然后像服务器请求数据)还是关键词从而决定是页面跳转还是通过默认的搜索引擎进行搜索

输入网址的情况，会让浏览器的网络线程接受到数据，网络线程接收到数据之后，会通过SafeBrowsing(谷歌内部的安全系统)判断是不是一个恶意网站或者在谷歌的黑名单网站上，

准备完毕之后，网络线程会通知UI进程，UI进程会创建一个渲染进程来进行页面的渲染

渲染进程做的事情👇

主要就是把js，css，js，image等浏览器资源渲染成可以进行交互的web页面

渲染进程主线程：

把html进行解析然后构造DOM数据结构

![](https://cdn.nlark.com/yuque/0/2023/png/32650608/1679020834190-18aced3f-370b-4119-bd62-75e9ebf93973.png)

html通过tokenniser标记化，通过词法分析构造DOM树，在这个过程中会构造document对象，然后以document为根节点构造DOM树，然后不断往里添加元素，并且修改，但是遇到js会转去先执行js，因为我们无法预知js中是否含有对于dom的修改操作

![](https://cdn.nlark.com/yuque/0/2023/png/32650608/1679020843261-7acc10a2-574b-4e81-95f8-4252d977752b.png)

![](https://cdn.nlark.com/yuque/0/2023/png/32650608/1679020848387-e3b77849-1f5c-4df8-8877-8e8641e7fbb2.png)

之后会进行css解析，如果节点没有样式就会使用默认样式，然后就进入到layout阶段，决定每个元素的位置

![](https://cdn.nlark.com/yuque/0/2023/png/32650608/1679020853674-7cc0846a-d5a9-45cc-91bb-1f9bcf62ba19.png)

主线程通过遍历dom和计算好的样式来生成layoutTree，layoutTree上每个节点都存储了xy坐标以及边框尺寸

（PS: domtree和layoutTree不是一一对应的，设置了display：none 的节点不会出现在layoutTree上，而添加了::before content的元素会出现在布局树上不会出现在dom树上）

![](https://cdn.nlark.com/yuque/0/2023/png/32650608/1679020861170-10e5a5b5-eba4-4196-b170-a886d44d7a7c.png)

下一步就是生成绘制记录表，然后决定绘制的顺序

![](https://cdn.nlark.com/yuque/0/2023/png/32650608/1679020865703-0f0f62e5-0bee-4271-9f16-b86b6478b594.png)

等做完了这些，我们就可以把这些数据转换成像素点进行显示了，这被称为栅格化（rastering）

主线程遍历layout tree 生成layer tree,当layer tree 绘制完毕切绘制顺序确定之后，主线程将信息传递给合成器线程

![](https://cdn.nlark.com/yuque/0/2023/png/32650608/1679020870736-1168de32-eff7-4474-9a94-4a1990e5b201.png)

合成器线程将每个图层栅格化，并且将图层切分为许多图块

![](https://cdn.nlark.com/yuque/0/2023/png/32650608/1679020875420-dbc3dd12-bdf4-4530-8cd1-7378cf5a9a70.png)

然后将每个图块发送给栅格线程，栅格线程栅格每个图块并且将其存储在GPU进程中，完成之后合成器进程会收集名为 draw quard的图块信息，这些信息记录了图块在内存中的位置和在页面的哪个位置绘制图块的信息，然后再根据这个图块信息生成一个合成器帧，合成器帧再通过IPC传递给浏览器进程，然后浏览器进程把合成器帧传送到GPU,然后GPU渲染显示

![](https://cdn.nlark.com/yuque/0/2023/png/32650608/1679020880319-c91d3b8a-568c-480c-9d3d-d35df414c598.png)