# JavaScript 异步编程详解

## 1. 异步编程基础

### 1.1 为什么需要异步编程

JavaScript 是单线程的，如果所有操作都是同步的，会导致阻塞，用户体验差。

```javascript
// 同步操作会阻塞
console.log("开始");
// 假设这是一个耗时 3 秒的操作
for (var i = 0; i < 3000000000; i++) {} // 阻塞 3 秒
console.log("结束"); // 3 秒后才执行

// 异步操作不会阻塞
console.log("开始");
setTimeout(function() {
  console.log("异步操作完成");
}, 3000);
console.log("结束"); // 立即执行
// 输出：开始 -> 结束 -> 异步操作完成
```

### 1.2 回调函数（Callback）

```javascript
/**
 * 回调函数：作为参数传递给另一个函数的函数
 * 在异步操作完成后执行
 */

// 基本回调
function fetchData(callback) {
  setTimeout(function() {
    var data = { name: "John", age: 30 };
    callback(data);
  }, 1000);
}

fetchData(function(data) {
  console.log("收到数据：", data);
});

// 错误处理回调
function fetchDataWithError(successCallback, errorCallback) {
  setTimeout(function() {
    var random = Math.random();
    if (random > 0.5) {
      successCallback({ name: "John" });
    } else {
      errorCallback(new Error("获取数据失败"));
    }
  }, 1000);
}

fetchDataWithError(
  function(data) {
    console.log("成功：", data);
  },
  function(error) {
    console.log("错误：", error.message);
  }
);

// Node.js 风格回调（错误优先）
function readFile(path, callback) {
  setTimeout(function() {
    var random = Math.random();
    if (random > 0.5) {
      callback(null, "文件内容"); // 第一个参数是错误，第二个是数据
    } else {
      callback(new Error("读取失败"), null);
    }
  }, 1000);
}

readFile("/path/to/file", function(err, data) {
  if (err) {
    console.log("错误：", err.message);
    return;
  }
  console.log("数据：", data);
});
```

### 1.3 回调地狱（Callback Hell）

```javascript
/**
 * 回调地狱：多层嵌套的回调函数，难以阅读和维护
 */

// 回调地狱示例
getData(function(a) {
  getMoreData(a, function(b) {
    getMoreData(b, function(c) {
      getMoreData(c, function(d) {
        getMoreData(d, function(e) {
          // 已经嵌套 5 层了，难以维护
          console.log(e);
        });
      });
    });
  });
});

// 解决方案：使用 Promise 或 async/await
```

## 2. Promise

### 2.1 Promise 基础

```javascript
/**
 * Promise 是异步操作的结果的占位符
 * 三种状态：pending（等待）、fulfilled（成功）、rejected（失败）
 */

// 创建 Promise
var promise = new Promise(function(resolve, reject) {
  // 异步操作
  setTimeout(function() {
    var random = Math.random();
    if (random > 0.5) {
      resolve("操作成功"); // 成功时调用 resolve
    } else {
      reject(new Error("操作失败")); // 失败时调用 reject
    }
  }, 1000);
});

// 处理 Promise
promise
  .then(function(value) {
    // 成功时执行
    console.log("成功：", value);
  })
  .catch(function(error) {
    // 失败时执行
    console.log("错误：", error.message);
  })
  .finally(function() {
    // 无论成功失败都执行
    console.log("完成");
  });
```

### 2.2 Promise 链式调用

```javascript
/**
 * Promise 的 then 方法返回新的 Promise，可以链式调用
 */

function fetchUser(id) {
  return new Promise(function(resolve) {
    setTimeout(function() {
      resolve({ id: id, name: "User " + id });
    }, 1000);
  });
}

function fetchPosts(userId) {
  return new Promise(function(resolve) {
    setTimeout(function() {
      resolve([
        { id: 1, userId: userId, title: "Post 1" },
        { id: 2, userId: userId, title: "Post 2" }
      ]);
    }, 1000);
  });
}

// 链式调用
fetchUser(1)
  .then(function(user) {
    console.log("用户：", user);
    return fetchPosts(user.id); // 返回新的 Promise
  })
  .then(function(posts) {
    console.log("文章：", posts);
    return posts.length; // 返回普通值，会被包装成 Promise
  })
  .then(function(count) {
    console.log("文章数量：", count);
  })
  .catch(function(error) {
    // 链中任何地方出错都会到这里
    console.log("错误：", error);
  });
```

### 2.3 Promise 静态方法

```javascript
/**
 * Promise.resolve()：创建已解决的 Promise
 * Promise.reject()：创建已拒绝的 Promise
 * Promise.all()：等待所有 Promise 完成
 * Promise.race()：等待第一个完成的 Promise
 * Promise.allSettled()：等待所有 Promise 完成（无论成功失败）
 * Promise.any()：等待第一个成功的 Promise
 */

// Promise.resolve()
var resolvedPromise = Promise.resolve("立即解决");
resolvedPromise.then(function(value) {
  console.log(value); // "立即解决"
});

// Promise.reject()
var rejectedPromise = Promise.reject(new Error("立即拒绝"));
rejectedPromise.catch(function(error) {
  console.log(error.message); // "立即拒绝"
});

// Promise.all() - 所有都成功才成功
var promise1 = Promise.resolve(1);
var promise2 = Promise.resolve(2);
var promise3 = Promise.resolve(3);

Promise.all([promise1, promise2, promise3])
  .then(function(values) {
    console.log(values); // [1, 2, 3]
  });

// 如果有一个失败，整个失败
var promise4 = Promise.reject(new Error("失败"));
Promise.all([promise1, promise2, promise4])
  .catch(function(error) {
    console.log(error.message); // "失败"
  });

// Promise.race() - 第一个完成的（无论成功失败）
var slowPromise = new Promise(function(resolve) {
  setTimeout(function() {
    resolve("慢的");
  }, 2000);
});

var fastPromise = new Promise(function(resolve) {
  setTimeout(function() {
    resolve("快的");
  }, 1000);
});

Promise.race([slowPromise, fastPromise])
  .then(function(value) {
    console.log(value); // "快的"（1秒后）
  });

// Promise.allSettled() - 等待所有完成
Promise.allSettled([promise1, promise4])
  .then(function(results) {
    console.log(results);
    // [
    //   { status: 'fulfilled', value: 1 },
    //   { status: 'rejected', reason: Error: 失败 }
    // ]
  });

// Promise.any() - 第一个成功的
var rejected1 = Promise.reject("错误1");
var rejected2 = Promise.reject("错误2");
var success = Promise.resolve("成功");

Promise.any([rejected1, rejected2, success])
  .then(function(value) {
    console.log(value); // "成功"
  });
```

### 2.4 Promise 实现

```javascript
/**
 * 简化版 Promise 实现（理解原理）
 */

function MyPromise(executor) {
  var self = this;
  self.state = "pending"; // pending, fulfilled, rejected
  self.value = undefined;
  self.reason = undefined;
  self.onFulfilledCallbacks = [];
  self.onRejectedCallbacks = [];

  function resolve(value) {
    if (self.state === "pending") {
      self.state = "fulfilled";
      self.value = value;
      self.onFulfilledCallbacks.forEach(function(callback) {
        callback(value);
      });
    }
  }

  function reject(reason) {
    if (self.state === "pending") {
      self.state = "rejected";
      self.reason = reason;
      self.onRejectedCallbacks.forEach(function(callback) {
        callback(reason);
      });
    }
  }

  try {
    executor(resolve, reject);
  } catch (error) {
    reject(error);
  }
}

MyPromise.prototype.then = function(onFulfilled, onRejected) {
  var self = this;
  var promise2 = new MyPromise(function(resolve, reject) {
    if (self.state === "fulfilled") {
      setTimeout(function() {
        try {
          var x = onFulfilled(self.value);
          resolvePromise(promise2, x, resolve, reject);
        } catch (error) {
          reject(error);
        }
      }, 0);
    } else if (self.state === "rejected") {
      setTimeout(function() {
        try {
          var x = onRejected(self.reason);
          resolvePromise(promise2, x, resolve, reject);
        } catch (error) {
          reject(error);
        }
      }, 0);
    } else if (self.state === "pending") {
      self.onFulfilledCallbacks.push(function() {
        setTimeout(function() {
          try {
            var x = onFulfilled(self.value);
            resolvePromise(promise2, x, resolve, reject);
          } catch (error) {
            reject(error);
          }
        }, 0);
      });
      self.onRejectedCallbacks.push(function() {
        setTimeout(function() {
          try {
            var x = onRejected(self.reason);
            resolvePromise(promise2, x, resolve, reject);
          } catch (error) {
            reject(error);
          }
        }, 0);
      });
    }
  });
  return promise2;
};

function resolvePromise(promise2, x, resolve, reject) {
  if (promise2 === x) {
    return reject(new TypeError("循环引用"));
  }
  if (x instanceof MyPromise) {
    x.then(resolve, reject);
  } else {
    resolve(x);
  }
}
```

## 3. async/await

### 3.1 async/await 基础

```javascript
/**
 * async/await 是 Promise 的语法糖，让异步代码看起来像同步代码
 * async 函数返回 Promise
 * await 等待 Promise 完成
 */

// async 函数
async function fetchData() {
  return "数据"; // 自动包装成 Promise.resolve("数据")
}

fetchData().then(function(value) {
  console.log(value); // "数据"
});

// await 等待 Promise
async function getData() {
  var data = await fetchData(); // 等待 Promise 完成
  console.log(data); // "数据"
  return data;
}

getData();

// 错误处理
async function getDataWithError() {
  try {
    var data = await Promise.reject(new Error("错误"));
  } catch (error) {
    console.log("捕获错误：", error.message); // "捕获错误：错误"
  }
}

getDataWithError();
```

### 3.2 async/await 链式调用

```javascript
/**
 * 使用 async/await 替代 Promise 链式调用
 */

// Promise 链式调用
function fetchUser(id) {
  return new Promise(function(resolve) {
    setTimeout(function() {
      resolve({ id: id, name: "User " + id });
    }, 1000);
  });
}

function fetchPosts(userId) {
  return new Promise(function(resolve) {
    setTimeout(function() {
      resolve([{ id: 1, title: "Post 1" }]);
    }, 1000);
  });
}

// Promise 方式
fetchUser(1)
  .then(function(user) {
    return fetchPosts(user.id);
  })
  .then(function(posts) {
    console.log(posts);
  });

// async/await 方式（更清晰）
async function getUserPosts() {
  var user = await fetchUser(1);
  var posts = await fetchPosts(user.id);
  console.log(posts);
}

getUserPosts();
```

### 3.3 并行处理

```javascript
/**
 * 使用 Promise.all() 并行处理多个异步操作
 */

async function fetchMultipleUsers() {
  // 串行（慢）
  var user1 = await fetchUser(1); // 等待 1 秒
  var user2 = await fetchUser(2); // 再等待 1 秒
  // 总共 2 秒

  // 并行（快）
  var [user3, user4] = await Promise.all([
    fetchUser(3), // 同时开始
    fetchUser(4)  // 同时开始
  ]);
  // 总共 1 秒

  console.log(user1, user2, user3, user4);
}

fetchMultipleUsers();

// 错误处理
async function fetchWithErrorHandling() {
  try {
    var [user1, user2] = await Promise.all([
      fetchUser(1),
      Promise.reject(new Error("失败"))
    ]);
  } catch (error) {
    // 任何一个失败都会进入 catch
    console.log("错误：", error.message);
  }
}

fetchWithErrorHandling();
```

## 4. 生成器（Generator）

### 4.1 Generator 基础

```javascript
/**
 * Generator 函数：可以暂停和恢复的函数
 * function* 定义
 * yield 暂停点
 */

function* numberGenerator() {
  yield 1;
  yield 2;
  yield 3;
  return 4;
}

var gen = numberGenerator();
console.log(gen.next()); // { value: 1, done: false }
console.log(gen.next()); // { value: 2, done: false }
console.log(gen.next()); // { value: 3, done: false }
console.log(gen.next()); // { value: 4, done: true }
console.log(gen.next()); // { value: undefined, done: true }
```

### 4.2 Generator 与异步

```javascript
/**
 * 使用 Generator 实现类似 async/await 的功能
 */

function fetchData() {
  return new Promise(function(resolve) {
    setTimeout(function() {
      resolve("数据");
    }, 1000);
  });
}

function* asyncGenerator() {
  var data = yield fetchData();
  console.log(data);
  var data2 = yield fetchData();
  console.log(data2);
}

// 手动执行 Generator
function run(generator) {
  var gen = generator();

  function handle(result) {
    if (result.done) return;
    result.value.then(function(data) {
      handle(gen.next(data));
    });
  }

  handle(gen.next());
}

run(asyncGenerator);
```

## 5. 实际应用示例

### 5.1 请求重试

```javascript
/**
 * 实现请求重试功能
 */

function fetchWithRetry(url, maxRetries = 3) {
  return new Promise(function(resolve, reject) {
    var attempts = 0;

    function attempt() {
      fetch(url)
        .then(function(response) {
          if (response.ok) {
            resolve(response);
          } else {
            throw new Error("请求失败");
          }
        })
        .catch(function(error) {
          attempts++;
          if (attempts < maxRetries) {
            console.log("重试 " + attempts + "/" + maxRetries);
            setTimeout(attempt, 1000 * attempts); // 指数退避
          } else {
            reject(error);
          }
        });
    }

    attempt();
  });
}

// async/await 版本
async function fetchWithRetryAsync(url, maxRetries = 3) {
  for (var i = 0; i < maxRetries; i++) {
    try {
      var response = await fetch(url);
      if (response.ok) {
        return response;
      }
      throw new Error("请求失败");
    } catch (error) {
      if (i === maxRetries - 1) {
        throw error;
      }
      console.log("重试 " + (i + 1) + "/" + maxRetries);
      await new Promise(function(resolve) {
        setTimeout(resolve, 1000 * (i + 1));
      });
    }
  }
}
```

### 5.2 超时控制

```javascript
/**
 * 为 Promise 添加超时功能
 */

function timeout(promise, ms) {
  return Promise.race([
    promise,
    new Promise(function(_, reject) {
      setTimeout(function() {
        reject(new Error("超时"));
      }, ms);
    })
  ]);
}

// 使用
timeout(fetch("https://api.example.com/data"), 5000)
  .then(function(response) {
    console.log("成功");
  })
  .catch(function(error) {
    console.log("错误：", error.message);
  });
```

### 5.3 并发控制

```javascript
/**
 * 控制并发数量
 */

async function limitConcurrency(tasks, limit) {
  var results = [];
  var executing = [];

  for (var i = 0; i < tasks.length; i++) {
    var task = tasks[i];
    var promise = Promise.resolve().then(function() {
      return task();
    });

    results.push(promise);

    if (limit <= tasks.length) {
      var e = promise.then(function() {
        executing.splice(executing.indexOf(e), 1);
      });
      executing.push(e);

      if (executing.length >= limit) {
        await Promise.race(executing);
      }
    }
  }

  return Promise.all(results);
}

// 使用
var tasks = [
  function() { return fetch("/api/1"); },
  function() { return fetch("/api/2"); },
  function() { return fetch("/api/3"); },
  function() { return fetch("/api/4"); },
  function() { return fetch("/api/5"); }
];

limitConcurrency(tasks, 2); // 最多同时 2 个请求
```

## 6. 总结

### 关键点：

1. **回调函数**：基础的异步处理方式，但容易产生回调地狱

2. **Promise**：
   - 三种状态：pending、fulfilled、rejected
   - 链式调用，更好的错误处理
   - Promise.all()、Promise.race() 等静态方法

3. **async/await**：
   - Promise 的语法糖，代码更清晰
   - 错误处理使用 try/catch
   - 并行处理使用 Promise.all()

4. **Generator**：
   - 可以暂停和恢复的函数
   - 可以用于实现类似 async/await 的功能

5. **最佳实践**：
   - 优先使用 async/await
   - 并行操作使用 Promise.all()
   - 添加超时和重试机制
   - 控制并发数量

