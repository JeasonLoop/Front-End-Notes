# JavaScript 内存管理和性能优化

## 1. 内存管理基础

### 1.1 内存生命周期

```javascript
/**
 * 内存生命周期：
 * 1. 分配：为变量分配内存
 * 2. 使用：读写内存
 * 3. 释放：不再需要时释放内存
 */

// 1. 分配内存
var obj = { name: "John" }; // 对象分配在堆内存

// 2. 使用内存
console.log(obj.name); // 读取内存

// 3. 释放内存（由垃圾回收器自动处理）
obj = null; // 解除引用，等待垃圾回收
```

### 1.2 栈内存和堆内存

```javascript
/**
 * 栈内存：存储基本类型和引用地址（快速访问）
 * 堆内存：存储对象（动态分配）
 */

// 基本类型存储在栈内存
var a = 10;
var b = "hello";
var c = true;

// 对象存储在堆内存，变量存储的是引用地址
var obj1 = { name: "John" }; // obj1 存储引用地址（栈），对象在堆
var obj2 = obj1;              // obj2 存储相同的引用地址
obj2.name = "Jane";
console.log(obj1.name); // "Jane"（同一个对象）
```

## 2. 垃圾回收（Garbage Collection）

### 2.1 引用计数

```javascript
/**
 * 引用计数：记录对象被引用的次数
 * 当引用次数为 0 时，对象可以被回收
 */

var obj1 = { name: "John" }; // obj1 引用对象，计数 = 1
var obj2 = obj1;              // obj2 引用同一对象，计数 = 2

obj1 = null;  // 计数 = 1
obj2 = null;  // 计数 = 0，对象可以被回收

// 循环引用问题
function createCycle() {
  var obj1 = {};
  var obj2 = {};
  obj1.ref = obj2; // obj1 引用 obj2
  obj2.ref = obj1; // obj2 引用 obj1（循环引用）
  return obj1;
}

var cycle = createCycle();
cycle = null; // 循环引用导致无法回收（旧版浏览器）
```

### 2.2 标记清除（Mark and Sweep）

```javascript
/**
 * 标记清除：现代浏览器主要使用的算法
 * 1. 标记：从根对象开始，标记所有可达对象
 * 2. 清除：清除未标记的对象
 */

// 标记清除可以处理循环引用
function createCycle() {
  var obj1 = {};
  var obj2 = {};
  obj1.ref = obj2;
  obj2.ref = obj1;
  return obj1;
}

var cycle = createCycle();
cycle = null; // 标记清除可以回收循环引用
```

### 2.3 分代回收

```javascript
/**
 * 分代回收：将对象分为新生代和老生代
 * - 新生代：新创建的对象，回收频繁
 * - 老生代：存活时间长的对象，回收较少
 */

// 新对象在新生代
var newObj = { data: "new" };

// 存活时间长的对象会晋升到老生代
function createLongLivedObject() {
  var obj = { data: "long-lived" };
  // 经过多次回收仍然存活
  return obj;
}
```

## 3. 内存泄漏

### 3.1 常见内存泄漏

#### 1. 全局变量

```javascript
/**
 * 全局变量不会被回收，导致内存泄漏
 */

// 错误：意外创建全局变量
function leak1() {
  name = "John"; // 没有 var/let/const，成为全局变量
}

// 正确：使用局部变量
function noLeak1() {
  var name = "John"; // 局部变量
}

// 错误：this 指向全局对象
function leak2() {
  this.name = "John"; // this 指向全局对象（非严格模式）
}

// 正确：使用严格模式
"use strict";
function noLeak2() {
  // this.name = "John"; // 报错：Cannot set property
}
```

#### 2. 闭包

```javascript
/**
 * 闭包持有外部变量引用，可能导致内存泄漏
 */

// 问题：闭包持有大对象
function createClosure() {
  var largeData = new Array(1000000).fill("data");

  return function() {
    // 即使不使用 largeData，闭包仍然持有引用
    console.log("Closure");
  };
}

var closure = createClosure();
// largeData 无法被回收

// 解决：不需要时清除引用
function createClosureFixed() {
  var largeData = new Array(1000000).fill("data");

  var closure = function() {
    console.log("Closure");
  };

  // 清除引用
  largeData = null;

  return closure;
}
```

#### 3. DOM 引用

```javascript
/**
 * DOM 元素引用导致内存泄漏
 */

// 问题：保存 DOM 引用
var elements = [];
function addElement() {
  var div = document.createElement("div");
  elements.push(div); // 保存引用
  document.body.appendChild(div);
}

// 即使移除 DOM，elements 数组仍持有引用
function removeElement() {
  var div = elements.pop();
  document.body.removeChild(div);
  // div 仍然在内存中（elements 数组引用）
}

// 解决：清除引用
function removeElementFixed() {
  var div = elements.pop();
  document.body.removeChild(div);
  div = null; // 清除引用
}
```

#### 4. 事件监听器

```javascript
/**
 * 未移除的事件监听器导致内存泄漏
 */

// 问题：添加事件监听器但未移除
function addListener() {
  var button = document.getElementById("button");
  button.addEventListener("click", function() {
    console.log("Clicked");
  });
  // 如果 button 被移除，监听器仍然存在
}

// 解决：保存引用并移除
function addListenerFixed() {
  var button = document.getElementById("button");
  var handler = function() {
    console.log("Clicked");
  };
  button.addEventListener("click", handler);

  // 移除时
  button.removeEventListener("click", handler);
  button = null;
}
```

#### 5. 定时器

```javascript
/**
 * 未清除的定时器导致内存泄漏
 */

// 问题：定时器未清除
function startTimer() {
  setInterval(function() {
    console.log("Timer");
  }, 1000);
  // 定时器一直运行，无法回收
}

// 解决：保存引用并清除
var timerId;
function startTimerFixed() {
  timerId = setInterval(function() {
    console.log("Timer");
  }, 1000);
}

function stopTimer() {
  clearInterval(timerId);
  timerId = null;
}
```

## 4. 性能优化技巧

### 4.1 减少内存分配

```javascript
/**
 * 减少不必要的内存分配
 */

// 问题：频繁创建对象
function processData(data) {
  var result = [];
  for (var i = 0; i < data.length; i++) {
    result.push({
      value: data[i],
      processed: true
    }); // 每次循环创建新对象
  }
  return result;
}

// 优化：复用对象
function processDataOptimized(data) {
  var result = [];
  var tempObj = {}; // 复用对象
  for (var i = 0; i < data.length; i++) {
    tempObj.value = data[i];
    tempObj.processed = true;
    result.push({ ...tempObj }); // 浅拷贝
  }
  return result;
}
```

### 4.2 避免全局查找

```javascript
/**
 * 缓存全局对象引用
 */

// 问题：频繁访问全局对象
function slowFunction() {
  for (var i = 0; i < 1000; i++) {
    document.getElementById("element").innerHTML = i; // 每次查找
  }
}

// 优化：缓存引用
function fastFunction() {
  var element = document.getElementById("element"); // 缓存引用
  for (var i = 0; i < 1000; i++) {
    element.innerHTML = i; // 使用缓存
  }
}
```

### 4.3 使用对象池

```javascript
/**
 * 对象池：复用对象，减少内存分配
 */

function ObjectPool(createFn, resetFn) {
  this.pool = [];
  this.createFn = createFn;
  this.resetFn = resetFn;
}

ObjectPool.prototype.acquire = function() {
  if (this.pool.length > 0) {
    return this.pool.pop(); // 复用对象
  }
  return this.createFn(); // 创建新对象
};

ObjectPool.prototype.release = function(obj) {
  this.resetFn(obj);
  this.pool.push(obj); // 放回池中
};

// 使用
var pool = new ObjectPool(
  function() {
    return { x: 0, y: 0 };
  },
  function(obj) {
    obj.x = 0;
    obj.y = 0;
  }
);

var obj1 = pool.acquire();
obj1.x = 10;
pool.release(obj1); // 放回池中

var obj2 = pool.acquire(); // 复用 obj1
console.log(obj2.x); // 0（已重置）
```

### 4.4 防抖和节流

```javascript
/**
 * 防抖和节流：减少函数执行频率
 */

// 防抖：延迟执行，如果再次触发则重新计时
function debounce(func, wait) {
  var timeout;
  return function() {
    var context = this;
    var args = arguments;
    clearTimeout(timeout);
    timeout = setTimeout(function() {
      func.apply(context, args);
    }, wait);
  };
}

// 节流：限制执行频率
function throttle(func, wait) {
  var lastTime = 0;
  return function() {
    var context = this;
    var args = arguments;
    var now = Date.now();
    if (now - lastTime >= wait) {
      lastTime = now;
      func.apply(context, args);
    }
  };
}

// 使用
var searchInput = document.getElementById("search");
var debouncedSearch = debounce(function(query) {
  // 搜索操作
  console.log("Searching:", query);
}, 300);

searchInput.addEventListener("input", function(e) {
  debouncedSearch(e.target.value);
});
```

### 4.5 虚拟滚动

```javascript
/**
 * 虚拟滚动：只渲染可见区域
 */

function VirtualList(container, itemHeight, totalItems, renderItem) {
  this.container = container;
  this.itemHeight = itemHeight;
  this.totalItems = totalItems;
  this.renderItem = renderItem;
  this.visibleCount = Math.ceil(container.clientHeight / itemHeight);
  this.scrollTop = 0;

  this.init();
}

VirtualList.prototype.init = function() {
  this.container.style.height = this.totalItems * this.itemHeight + "px";
  this.container.addEventListener("scroll", this.handleScroll.bind(this));
  this.render();
};

VirtualList.prototype.handleScroll = function() {
  this.scrollTop = this.container.scrollTop;
  this.render();
};

VirtualList.prototype.render = function() {
  var startIndex = Math.floor(this.scrollTop / this.itemHeight);
  var endIndex = Math.min(startIndex + this.visibleCount + 1, this.totalItems);

  var fragment = document.createDocumentFragment();
  for (var i = startIndex; i < endIndex; i++) {
    var item = this.renderItem(i);
    item.style.position = "absolute";
    item.style.top = i * this.itemHeight + "px";
    fragment.appendChild(item);
  }

  this.container.innerHTML = "";
  this.container.appendChild(fragment);
};
```

### 4.6 代码分割

```javascript
/**
 * 代码分割：按需加载
 */

// 动态导入（ES2020）
async function loadModule() {
  var module = await import("./heavy-module.js");
  module.doSomething();
}

// 条件加载
if (condition) {
  import("./module-a.js").then(function(module) {
    module.init();
  });
} else {
  import("./module-b.js").then(function(module) {
    module.init();
  });
}
```

## 5. 性能监控

### 5.1 内存监控

```javascript
/**
 * 使用 Performance API 监控内存
 */

// 检查是否支持内存 API
if (performance.memory) {
  var memory = performance.memory;
  console.log("Used: " + (memory.usedJSHeapSize / 1048576).toFixed(2) + " MB");
  console.log("Total: " + (memory.totalJSHeapSize / 1048576).toFixed(2) + " MB");
  console.log("Limit: " + (memory.jsHeapSizeLimit / 1048576).toFixed(2) + " MB");
}

// 监控内存泄漏
function monitorMemory() {
  if (performance.memory) {
    var used = performance.memory.usedJSHeapSize;
    console.log("Memory used: " + (used / 1048576).toFixed(2) + " MB");

    // 如果内存持续增长，可能存在泄漏
    if (used > 100 * 1048576) { // 100MB
      console.warn("High memory usage detected!");
    }
  }
}

setInterval(monitorMemory, 5000);
```

### 5.2 性能分析

```javascript
/**
 * 使用 Performance API 分析性能
 */

// 标记开始
performance.mark("start");

// 执行操作
for (var i = 0; i < 1000000; i++) {
  // 一些操作
}

// 标记结束
performance.mark("end");

// 测量
performance.measure("operation", "start", "end");

// 获取测量结果
var measure = performance.getEntriesByName("operation")[0];
console.log("Duration: " + measure.duration + " ms");

// 清除标记
performance.clearMarks();
performance.clearMeasures();
```

## 6. 最佳实践

### 6.1 内存管理

```javascript
/**
 * 内存管理最佳实践
 */

// 1. 及时清除引用
function cleanup() {
  var data = getLargeData();
  // 使用数据
  processData(data);
  // 清除引用
  data = null;
}

// 2. 避免循环引用
function avoidCircularReference() {
  var obj1 = {};
  var obj2 = {};
  obj1.ref = obj2;
  // 不再需要时清除
  obj1.ref = null;
  obj1 = null;
  obj2 = null;
}

// 3. 使用 WeakMap/WeakSet（弱引用）
var weakMap = new WeakMap();
var obj = {};
weakMap.set(obj, "value");
// obj 被回收时，WeakMap 中的条目也会被自动清除
obj = null;
```

### 6.2 性能优化

```javascript
/**
 * 性能优化最佳实践
 */

// 1. 批量 DOM 操作
function batchDOMOperations() {
  var fragment = document.createDocumentFragment();
  for (var i = 0; i < 1000; i++) {
    var div = document.createElement("div");
    fragment.appendChild(div);
  }
  document.body.appendChild(fragment); // 一次插入
}

// 2. 使用 requestAnimationFrame
function animate() {
  // 动画逻辑
  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);

// 3. 使用 Web Workers 处理耗时任务
var worker = new Worker("worker.js");
worker.postMessage({ data: largeData });
worker.onmessage = function(event) {
  console.log("Result:", event.data);
};
```

## 7. 总结

### 关键点：

1. **内存管理**：
   - 理解栈内存和堆内存
   - 了解垃圾回收机制
   - 避免内存泄漏

2. **常见泄漏**：
   - 全局变量
   - 闭包持有大对象
   - DOM 引用
   - 事件监听器
   - 定时器

3. **性能优化**：
   - 减少内存分配
   - 缓存引用
   - 使用对象池
   - 防抖和节流
   - 虚拟滚动
   - 代码分割

4. **监控工具**：
   - Performance API
   - Chrome DevTools
   - 内存分析工具

5. **最佳实践**：
   - 及时清除引用
   - 避免循环引用
   - 使用弱引用
   - 批量操作
   - 合理使用异步

性能和内存管理需要持续关注和优化。

