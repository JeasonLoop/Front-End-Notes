# JavaScript 模块化和打包

## 1. 模块化概述

模块化是将代码分割成独立、可重用的模块。JavaScript 有多种模块系统：

- CommonJS（Node.js）
- AMD（RequireJS）
- ES Modules（ES6+）
- UMD（通用模块定义）

## 2. CommonJS

### 2.1 导出（module.exports）

```javascript
/**
 * CommonJS：Node.js 使用的模块系统
 * 同步加载，适合服务器端
 */

// math.js
// 方式1：导出单个值
module.exports = function add(a, b) {
  return a + b;
};

// 方式2：导出对象
module.exports = {
  add: function(a, b) {
    return a + b;
  },
  subtract: function(a, b) {
    return a - b;
  },
  PI: 3.14159
};

// 方式3：使用 exports（module.exports 的简写）
exports.add = function(a, b) {
  return a + b;
};

exports.subtract = function(a, b) {
  return a - b;
};

// 注意：不能直接给 exports 赋值
// exports = { add: ... }; // 错误，不会导出
```

### 2.2 导入（require）

```javascript
/**
 * require：同步加载模块
 */

// 导入单个值
var add = require("./math.js");
console.log(add(1, 2)); // 3

// 导入对象
var math = require("./math.js");
console.log(math.add(1, 2));      // 3
console.log(math.subtract(5, 2)); // 3

// 解构导入
var { add, subtract } = require("./math.js");

// 导入 Node.js 内置模块
var fs = require("fs");
var path = require("path");

// 导入 npm 包
var lodash = require("lodash");

// 缓存：同一模块只加载一次
var math1 = require("./math.js");
var math2 = require("./math.js");
console.log(math1 === math2); // true（同一个对象）
```

### 2.3 CommonJS 特点

```javascript
/**
 * CommonJS 特点：
 * 1. 同步加载
 * 2. 运行时加载
 * 3. 值拷贝（导出的是值的拷贝）
 */

// 值拷贝示例
// counter.js
var count = 0;
function increment() {
  count++;
}
module.exports = {
  count: count,
  increment: increment
};

// main.js
var counter = require("./counter.js");
console.log(counter.count); // 0
counter.increment();
console.log(counter.count); // 0（值拷贝，不会改变）
```

## 3. ES Modules（ESM）

### 3.1 导出（export）

```javascript
/**
 * ES Modules：ES6+ 标准模块系统
 * 静态分析，适合浏览器和 Node.js
 */

// math.js
// 命名导出
export function add(a, b) {
  return a + b;
}

export function subtract(a, b) {
  return a - b;
}

export const PI = 3.14159;

// 或者统一导出
function multiply(a, b) {
  return a * b;
}

function divide(a, b) {
  return a / b;
}

export { multiply, divide };

// 重命名导出
export { add as sum, subtract as sub };

// 默认导出（一个模块只能有一个）
export default function multiply(a, b) {
  return a * b;
}

// 或者
export default {
  multiply: function(a, b) {
    return a * b;
  }
};
```

### 3.2 导入（import）

```javascript
/**
 * import：静态导入，编译时确定
 */

// 命名导入
import { add, subtract } from "./math.js";
console.log(add(1, 2)); // 3

// 导入所有
import * as math from "./math.js";
console.log(math.add(1, 2));
console.log(math.PI);

// 默认导入
import multiply from "./math.js";
console.log(multiply(2, 3)); // 6

// 混合导入
import multiply, { add, subtract } from "./math.js";

// 重命名导入
import { add as sum } from "./math.js";

// 只导入（执行模块，不导入任何值）
import "./math.js";

// 动态导入（ES2020）
async function loadModule() {
  var math = await import("./math.js");
  console.log(math.add(1, 2));
}

// 条件导入
if (condition) {
  import("./module-a.js").then(function(module) {
    module.doSomething();
  });
}
```

### 3.3 ES Modules 特点

```javascript
/**
 * ES Modules 特点：
 * 1. 静态分析（编译时确定依赖）
 * 2. 值引用（导出的是值的引用）
 * 3. 严格模式
 * 4. 顶层 this 是 undefined
 */

// 值引用示例
// counter.js
export var count = 0;
export function increment() {
  count++;
}

// main.js
import { count, increment } from "./counter.js";
console.log(count); // 0
increment();
console.log(count); // 1（值引用，会改变）

// 严格模式
// 自动启用严格模式，不需要 "use strict"
export function strictFunction() {
  // 严格模式特性
  // this === undefined
}
```

## 4. AMD（Asynchronous Module Definition）

### 4.1 AMD 基础

```javascript
/**
 * AMD：异步模块定义，适合浏览器
 * 使用 RequireJS
 */

// 定义模块
define(["dependency1", "dependency2"], function(dep1, dep2) {
  // 模块代码
  function add(a, b) {
    return a + b;
  }

  // 返回模块接口
  return {
    add: add
  };
});

// 无依赖模块
define(function() {
  return {
    name: "My Module"
  };
});

// 加载模块
require(["math"], function(math) {
  console.log(math.add(1, 2));
});
```

## 5. UMD（Universal Module Definition）

### 5.1 UMD 基础

```javascript
/**
 * UMD：通用模块定义，兼容多种模块系统
 */

(function(root, factory) {
  // CommonJS
  if (typeof module === "object" && typeof module.exports === "object") {
    module.exports = factory();
  }
  // AMD
  else if (typeof define === "function" && define.amd) {
    define(factory);
  }
  // 全局变量
  else {
    root.MyModule = factory();
  }
}(typeof self !== "undefined" ? self : this, function() {
  // 模块代码
  return {
    add: function(a, b) {
      return a + b;
    }
  };
}));
```

## 6. 打包工具

### 6.1 Webpack

#### 6.1.1 Webpack 基础配置

```javascript
/**
 * webpack.config.js
 * Webpack：模块打包器
 */

module.exports = {
  // 入口文件
  entry: "./src/index.js",

  // 输出配置
  output: {
    filename: "bundle.js",
    path: __dirname + "/dist"
  },

  // 模块规则
  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        use: {
          loader: "babel-loader",
          options: {
            presets: ["@babel/preset-env"]
          }
        }
      },
      {
        test: /\.css$/,
        use: ["style-loader", "css-loader"]
      }
    ]
  },

  // 插件
  plugins: [
    new HtmlWebpackPlugin({
      template: "./src/index.html"
    })
  ],

  // 开发服务器
  devServer: {
    contentBase: "./dist",
    port: 3000
  },

  // 模式
  mode: "production" // 或 "development"
};
```

#### 6.1.2 Webpack 代码分割

```javascript
/**
 * 代码分割：按需加载
 */

// 动态导入
import(/* webpackChunkName: "math" */ "./math.js")
  .then(function(math) {
    console.log(math.add(1, 2));
  });

// 路由懒加载
const Home = () => import(/* webpackChunkName: "home" */ "./Home.vue");
const About = () => import(/* webpackChunkName: "about" */ "./About.vue");

// SplitChunksPlugin 配置
module.exports = {
  optimization: {
    splitChunks: {
      chunks: "all",
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: "vendors",
          chunks: "all"
        }
      }
    }
  }
};
```

### 6.2 Vite

#### 6.2.1 Vite 基础

```javascript
/**
 * vite.config.js
 * Vite：快速的构建工具，使用 ES Modules
 */

import { defineConfig } from "vite";
import vue from "@vitejs/plugin-vue";

export default defineConfig({
  plugins: [vue()],

  // 开发服务器
  server: {
    port: 3000,
    open: true
  },

  // 构建配置
  build: {
    outDir: "dist",
    sourcemap: true
  },

  // 路径别名
  resolve: {
    alias: {
      "@": "/src"
    }
  }
});
```

#### 6.2.2 Vite 特点

```javascript
/**
 * Vite 特点：
 * 1. 开发时使用 ES Modules，无需打包
 * 2. 生产构建使用 Rollup
 * 3. 快速热更新（HMR）
 * 4. 按需编译
 */

// 开发时：直接使用 ES Modules
import { createApp } from "vue";
import App from "./App.vue";

createApp(App).mount("#app");

// 生产构建：自动优化和打包
```

### 6.3 Rollup

```javascript
/**
 * rollup.config.js
 * Rollup：ES Modules 打包器，适合库开发
 */

export default {
  input: "src/index.js",
  output: {
    file: "dist/bundle.js",
    format: "umd", // amd, cjs, es, iife, umd
    name: "MyLibrary"
  },
  external: ["lodash"], // 外部依赖
  plugins: [
    // 插件
  ]
};
```

## 7. 模块化最佳实践

### 7.1 文件组织

```
src/
├── components/      # 组件模块
│   ├── Button.js
│   └── Input.js
├── utils/          # 工具模块
│   ├── math.js
│   └── string.js
├── services/       # 服务模块
│   └── api.js
├── constants/      # 常量模块
│   └── config.js
└── index.js        # 入口文件
```

### 7.2 模块设计原则

```javascript
/**
 * 模块设计原则：
 * 1. 单一职责：一个模块只做一件事
 * 2. 高内聚低耦合：模块内部紧密，模块间松散
 * 3. 明确接口：清晰的导入导出
 * 4. 避免循环依赖
 */

// 好的模块设计
// math.js：单一职责
export function add(a, b) {
  return a + b;
}

export function subtract(a, b) {
  return a - b;
}

// 避免循环依赖
// module-a.js
import { funcB } from "./module-b.js";
export function funcA() {
  funcB();
}

// module-b.js
import { funcA } from "./module-a.js"; // 循环依赖，避免
export function funcB() {
  funcA();
}
```

### 7.3 Tree Shaking

```javascript
/**
 * Tree Shaking：移除未使用的代码
 * 需要 ES Modules 和构建工具支持
 */

// math.js
export function add(a, b) {
  return a + b;
}

export function subtract(a, b) {
  return a - b;
}

// main.js
import { add } from "./math.js";
// 只导入 add，subtract 会被 tree shaking 移除

console.log(add(1, 2));
```

## 8. 实际应用示例

### 8.1 模块化项目结构

```javascript
/**
 * 模块化项目示例
 */

// src/utils/helpers.js
export function formatDate(date) {
  return date.toLocaleDateString();
}

export function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

// src/services/api.js
export class ApiService {
  constructor(baseURL) {
    this.baseURL = baseURL;
  }

  async get(endpoint) {
    const response = await fetch(`${this.baseURL}${endpoint}`);
    return response.json();
  }
}

// src/index.js
import { formatDate, capitalize } from "./utils/helpers.js";
import { ApiService } from "./services/api.js";

const api = new ApiService("https://api.example.com");
const data = await api.get("/users");
console.log(formatDate(new Date()));
```

### 8.2 条件加载

```javascript
/**
 * 根据环境加载不同模块
 */

// 开发环境
if (process.env.NODE_ENV === "development") {
  import("./dev-tools.js").then(function(devTools) {
    devTools.init();
  });
}

// 功能检测
if ("serviceWorker" in navigator) {
  import("./sw.js").then(function(sw) {
    sw.register();
  });
}
```

## 9. 总结

### 关键点：

1. **模块系统**：
   - CommonJS：Node.js，同步加载
   - ES Modules：标准，静态分析
   - AMD：浏览器，异步加载
   - UMD：通用，兼容多种系统

2. **打包工具**：
   - Webpack：功能强大，配置复杂
   - Vite：快速，开发体验好
   - Rollup：适合库开发

3. **最佳实践**：
   - 单一职责
   - 避免循环依赖
   - 使用 Tree Shaking
   - 合理组织文件结构

4. **选择建议**：
   - Node.js：CommonJS 或 ES Modules
   - 浏览器：ES Modules + 打包工具
   - 库开发：ES Modules + Rollup
   - 现代项目：ES Modules + Vite/Webpack

模块化让代码更易维护、测试和重用。

