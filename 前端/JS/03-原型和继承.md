# JavaScript 原型和继承

## 1. 原型（Prototype）

### 1.1 什么是原型

每个 JavaScript 对象都有一个指向另一个对象的内部链接，这个对象就是原型（prototype）。当我们访问对象的属性时，如果对象本身没有该属性，JavaScript 会沿着原型链向上查找。

```javascript
// 每个对象都有 __proto__ 属性（已废弃，但浏览器仍支持）
// 推荐使用 Object.getPrototypeOf()

var obj = {};
console.log(obj.__proto__);                    // Object.prototype
console.log(Object.getPrototypeOf(obj));       // Object.prototype
console.log(Object.getPrototypeOf(obj) === Object.prototype); // true
```

### 1.2 原型链

```javascript
// 原型链：对象 -> Object.prototype -> null
var obj = { name: "test" };

// obj 的原型是 Object.prototype
console.log(Object.getPrototypeOf(obj) === Object.prototype); // true

// Object.prototype 的原型是 null
console.log(Object.getPrototypeOf(Object.prototype)); // null

// 访问属性时的查找顺序
console.log(obj.toString); // 从 Object.prototype 继承的方法
console.log(obj.name);     // obj 自身的属性
```

### 1.3 函数的 prototype 属性

```javascript
/**
 * 每个函数都有一个 prototype 属性
 * 当使用 new 调用函数时，新对象的 __proto__ 会指向函数的 prototype
 */

function Person(name) {
  this.name = name;
}

// Person.prototype 是原型对象
console.log(Person.prototype); // Person {}

// 添加方法到原型
Person.prototype.sayHello = function() {
  console.log("Hello, I'm " + this.name);
};

var person1 = new Person("Alice");
var person2 = new Person("Bob");

// 两个实例共享同一个原型方法
console.log(person1.sayHello === person2.sayHello); // true

person1.sayHello(); // "Hello, I'm Alice"
person2.sayHello(); // "Hello, I'm Bob"

// 原型链：person1 -> Person.prototype -> Object.prototype -> null
console.log(Object.getPrototypeOf(person1) === Person.prototype); // true
console.log(Object.getPrototypeOf(Person.prototype) === Object.prototype); // true
```

### 1.4 constructor 属性

```javascript
function Person(name) {
  this.name = name;
}

// 每个原型对象都有一个 constructor 属性，指向构造函数
console.log(Person.prototype.constructor === Person); // true

var person = new Person("Alice");
// 实例的 constructor 属性来自原型
console.log(person.constructor === Person); // true

// 但是 constructor 可以被覆盖
Person.prototype = {
  sayHello: function() {
    console.log("Hello");
  }
};

var person2 = new Person("Bob");
console.log(person2.constructor === Person); // false（指向 Object）
console.log(person2.constructor === Object); // true

// 修复 constructor
Person.prototype.constructor = Person;
console.log(person2.constructor === Person); // true
```

## 2. 原型继承

### 2.1 原型链继承

```javascript
/**
 * 原型链继承：子类的原型指向父类的实例
 * 优点：简单
 * 缺点：引用类型属性被所有实例共享；无法向父类传参
 */

// 父类
function Animal(name) {
  this.name = name;
  this.colors = ["red", "blue"]; // 引用类型
}

Animal.prototype.eat = function() {
  console.log(this.name + " is eating");
};

// 子类
function Dog(name, breed) {
  this.name = name;
  this.breed = breed;
}

// 原型链继承：Dog 的原型指向 Animal 的实例
Dog.prototype = new Animal();
Dog.prototype.constructor = Dog; // 修复 constructor

Dog.prototype.bark = function() {
  console.log(this.name + " is barking");
};

var dog1 = new Dog("旺财", "金毛");
var dog2 = new Dog("来福", "哈士奇");

dog1.eat();  // "旺财 is eating"（继承自 Animal）
dog1.bark(); // "旺财 is barking"

// 问题1：引用类型属性被共享
dog1.colors.push("green");
console.log(dog1.colors); // ["red", "blue", "green"]
console.log(dog2.colors); // ["red", "blue", "green"]（也被修改了）

// 问题2：无法向父类传参
// 在创建 Dog.prototype = new Animal() 时，无法传递参数
```

### 2.2 构造函数继承（借用构造函数）

```javascript
/**
 * 构造函数继承：在子类中调用父类构造函数
 * 优点：可以传递参数；引用类型属性不共享
 * 缺点：无法继承父类原型上的方法
 */

function Animal(name) {
  this.name = name;
  this.colors = ["red", "blue"];
}

Animal.prototype.eat = function() {
  console.log(this.name + " is eating");
};

function Dog(name, breed) {
  // 调用父类构造函数，绑定 this 到当前实例
  Animal.call(this, name);
  this.breed = breed;
}

var dog1 = new Dog("旺财", "金毛");
var dog2 = new Dog("来福", "哈士奇");

dog1.colors.push("green");
console.log(dog1.colors); // ["red", "blue", "green"]
console.log(dog2.colors); // ["red", "blue"]（不共享）

// 缺点：无法继承原型方法
// dog1.eat(); // 报错：dog1.eat is not a function
```

### 2.3 组合继承（原型链 + 构造函数）

```javascript
/**
 * 组合继承：结合原型链继承和构造函数继承
 * 优点：可以传递参数；引用类型不共享；可以继承原型方法
 * 缺点：父类构造函数被调用两次
 */

function Animal(name) {
  this.name = name;
  this.colors = ["red", "blue"];
}

Animal.prototype.eat = function() {
  console.log(this.name + " is eating");
};

function Dog(name, breed) {
  // 第一次调用父类构造函数
  Animal.call(this, name);
  this.breed = breed;
}

// 第二次调用父类构造函数
Dog.prototype = new Animal();
Dog.prototype.constructor = Dog;

Dog.prototype.bark = function() {
  console.log(this.name + " is barking");
};

var dog1 = new Dog("旺财", "金毛");
var dog2 = new Dog("来福", "哈士奇");

dog1.eat();  // "旺财 is eating"
dog1.bark(); // "旺财 is barking"

dog1.colors.push("green");
console.log(dog1.colors); // ["red", "blue", "green"]
console.log(dog2.colors); // ["red", "blue"]（不共享）
```

### 2.4 原型式继承

```javascript
/**
 * 原型式继承：基于已有对象创建新对象
 * Object.create() 的实现原理
 */

function object(o) {
  function F() {}
  F.prototype = o;
  return new F();
}

var person = {
  name: "John",
  friends: ["Alice", "Bob"]
};

var person1 = object(person);
person1.name = "Greg";
person1.friends.push("Charlie");

var person2 = object(person);
person2.name = "Linda";
person2.friends.push("David");

console.log(person.friends); // ["Alice", "Bob", "Charlie", "David"]（共享）

// ES5 的 Object.create()
var person3 = Object.create(person);
person3.name = "Mike";
console.log(person3.friends); // 继承自 person
```

### 2.5 寄生式继承

```javascript
/**
 * 寄生式继承：在原型式继承基础上增强对象
 */

function createAnother(original) {
  // 基于 original 创建新对象
  var clone = Object.create(original);

  // 增强对象
  clone.sayHi = function() {
    console.log("Hi");
  };

  return clone;
}

var person = {
  name: "John",
  friends: ["Alice", "Bob"]
};

var anotherPerson = createAnother(person);
anotherPerson.sayHi(); // "Hi"
```

### 2.6 寄生组合式继承（最佳实践）

```javascript
/**
 * 寄生组合式继承：最理想的继承方式
 * 优点：只调用一次父类构造函数；避免不必要的属性；原型链保持不变
 */

function inheritPrototype(subType, superType) {
  // 创建父类原型的副本
  var prototype = Object.create(superType.prototype);
  // 修复 constructor
  prototype.constructor = subType;
  // 将副本赋值给子类原型
  subType.prototype = prototype;
}

function Animal(name) {
  this.name = name;
  this.colors = ["red", "blue"];
}

Animal.prototype.eat = function() {
  console.log(this.name + " is eating");
};

function Dog(name, breed) {
  // 只调用一次父类构造函数
  Animal.call(this, name);
  this.breed = breed;
}

// 使用寄生组合式继承
inheritPrototype(Dog, Animal);

Dog.prototype.bark = function() {
  console.log(this.name + " is barking");
};

var dog1 = new Dog("旺财", "金毛");
var dog2 = new Dog("来福", "哈士奇");

dog1.eat();  // "旺财 is eating"
dog1.bark(); // "旺财 is barking"

dog1.colors.push("green");
console.log(dog1.colors); // ["red", "blue", "green"]
console.log(dog2.colors); // ["red", "blue"]（不共享）
```

## 3. ES6 Class 继承

### 3.1 Class 基本语法

```javascript
/**
 * ES6 Class 是构造函数的语法糖
 * 本质仍然是基于原型的继承
 */

class Animal {
  // 构造函数
  constructor(name) {
    this.name = name;
    this.colors = ["red", "blue"];
  }

  // 实例方法（添加到原型上）
  eat() {
    console.log(this.name + " is eating");
  }

  // 静态方法（添加到构造函数上）
  static getSpecies() {
    return "Animal";
  }

  // Getter
  get info() {
    return this.name + " is an animal";
  }

  // Setter
  set name(value) {
    this._name = value;
  }
}

// 等价于：
function Animal(name) {
  this.name = name;
  this.colors = ["red", "blue"];
}

Animal.prototype.eat = function() {
  console.log(this.name + " is eating");
};

Animal.getSpecies = function() {
  return "Animal";
};

var animal = new Animal("Dog");
animal.eat();              // "Dog is eating"
Animal.getSpecies();       // "Animal"
console.log(animal.info); // "Dog is an animal"
```

### 3.2 Class 继承

```javascript
/**
 * ES6 Class 继承使用 extends 关键字
 * 内部实现就是寄生组合式继承
 */

class Animal {
  constructor(name) {
    this.name = name;
    this.colors = ["red", "blue"];
  }

  eat() {
    console.log(this.name + " is eating");
  }
}

class Dog extends Animal {
  constructor(name, breed) {
    // 必须调用 super()，相当于 Animal.call(this, name)
    super(name);
    this.breed = breed;
  }

  // 重写父类方法
  eat() {
    super.eat(); // 调用父类方法
    console.log(this.name + " is eating dog food");
  }

  bark() {
    console.log(this.name + " is barking");
  }
}

var dog = new Dog("旺财", "金毛");
dog.eat();  // "旺财 is eating" 和 "旺财 is eating dog food"
dog.bark(); // "旺财 is barking"

// 检查继承关系
console.log(dog instanceof Dog);    // true
console.log(dog instanceof Animal);  // true
console.log(Object.getPrototypeOf(Dog.prototype) === Animal.prototype); // true
```

### 3.3 静态方法继承

```javascript
class Animal {
  static getSpecies() {
    return "Animal";
  }
}

class Dog extends Animal {
  static getSpecies() {
    return super.getSpecies() + " - Dog";
  }
}

console.log(Animal.getSpecies()); // "Animal"
console.log(Dog.getSpecies());    // "Animal - Dog"
```

## 4. 原型相关方法

### 4.1 Object.create()

```javascript
/**
 * Object.create(proto, propertiesObject)
 * 创建一个新对象，使用现有对象作为新对象的原型
 */

var person = {
  name: "John",
  sayHello: function() {
    console.log("Hello, I'm " + this.name);
  }
};

// 创建以 person 为原型的对象
var person1 = Object.create(person);
person1.name = "Alice";
person1.sayHello(); // "Hello, I'm Alice"

// 第二个参数：属性描述符
var person2 = Object.create(person, {
  name: {
    value: "Bob",
    writable: true,
    enumerable: true,
    configurable: true
  },
  age: {
    value: 30,
    writable: false,
    enumerable: true,
    configurable: false
  }
});

person2.sayHello(); // "Hello, I'm Bob"
console.log(person2.age); // 30
```

### 4.2 Object.getPrototypeOf() 和 Object.setPrototypeOf()

```javascript
var obj = {};
var proto = { name: "prototype" };

// 获取原型
console.log(Object.getPrototypeOf(obj) === Object.prototype); // true

// 设置原型（不推荐，性能差）
Object.setPrototypeOf(obj, proto);
console.log(Object.getPrototypeOf(obj) === proto); // true
console.log(obj.name); // "prototype"
```

### 4.3 Object.hasOwnProperty()

```javascript
/**
 * 检查对象自身是否具有指定属性（不包括原型链）
 */

function Person(name) {
  this.name = name;
}

Person.prototype.sayHello = function() {
  console.log("Hello");
};

var person = new Person("John");

console.log(person.hasOwnProperty("name"));     // true（自身属性）
console.log(person.hasOwnProperty("sayHello"));  // false（原型属性）
console.log(person.hasOwnProperty("toString"));   // false（继承属性）

// 更安全的方式（避免 hasOwnProperty 被覆盖）
console.log(Object.prototype.hasOwnProperty.call(person, "name")); // true
// ES2022 新方法
console.log(Object.hasOwn(person, "name")); // true
```

### 4.4 instanceof 操作符

```javascript
/**
 * instanceof 检查对象的原型链中是否存在构造函数的 prototype
 * obj instanceof Constructor
 */

function Animal() {}
function Dog() {}

Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

var dog = new Dog();

console.log(dog instanceof Dog);    // true
console.log(dog instanceof Animal);  // true
console.log(dog instanceof Object); // true

// 手动实现 instanceof
function myInstanceof(left, right) {
  // 获取对象的原型
  var proto = Object.getPrototypeOf(left);
  // 获取构造函数的 prototype
  var prototype = right.prototype;

  // 沿着原型链向上查找
  while (proto !== null) {
    if (proto === prototype) {
      return true;
    }
    proto = Object.getPrototypeOf(proto);
  }

  return false;
}

console.log(myInstanceof(dog, Dog));    // true
console.log(myInstanceof(dog, Animal)); // true
```

## 5. 实际应用示例

### 5.1 混入（Mixin）

```javascript
/**
 * 混入：将多个对象的属性和方法合并到一个对象
 */

// 混入函数
function mixin(target, ...sources) {
  sources.forEach(source => {
    Object.getOwnPropertyNames(source).forEach(name => {
      // 复制属性描述符
      var descriptor = Object.getOwnPropertyDescriptor(source, name);
      Object.defineProperty(target, name, descriptor);
    });
  });
  return target;
}

var canEat = {
  eat: function() {
    console.log(this.name + " is eating");
  }
};

var canFly = {
  fly: function() {
    console.log(this.name + " is flying");
  }
};

function Bird(name) {
  this.name = name;
}

// 混入能力
mixin(Bird.prototype, canEat, canFly);

var bird = new Bird("Eagle");
bird.eat(); // "Eagle is eating"
bird.fly(); // "Eagle is flying"
```

### 5.2 多继承模拟

```javascript
/**
 * JavaScript 不支持多继承，但可以通过混入模拟
 */

class Animal {
  constructor(name) {
    this.name = name;
  }

  eat() {
    console.log(this.name + " is eating");
  }
}

// Mixin 1
const CanFly = {
  fly() {
    console.log(this.name + " is flying");
  }
};

// Mixin 2
const CanSwim = {
  swim() {
    console.log(this.name + " is swimming");
  }
};

// 混入函数
function applyMixins(derivedCtor, baseCtors) {
  baseCtors.forEach(baseCtor => {
    Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {
      if (name !== "constructor") {
        derivedCtor.prototype[name] = baseCtor.prototype[name];
      }
    });
  });
}

class Duck extends Animal {
  constructor(name) {
    super(name);
  }
}

// 应用混入
Object.assign(Duck.prototype, CanFly, CanSwim);

var duck = new Duck("Donald");
duck.eat();  // "Donald is eating"
duck.fly();  // "Donald is flying"
duck.swim(); // "Donald is swimming"
```

## 6. 总结

### 关键点：

1. **原型链**：对象 -> 构造函数.prototype -> Object.prototype -> null

2. **继承方式**：
   - 原型链继承：简单但有问题
   - 构造函数继承：可传参但不继承原型方法
   - 组合继承：常用但调用两次父类构造函数
   - 寄生组合式继承：最佳实践

3. **ES6 Class**：
   - 语法糖，本质仍是原型继承
   - 使用 extends 和 super
   - 更清晰易读

4. **相关方法**：
   - `Object.create()`：创建以指定对象为原型的对象
   - `Object.getPrototypeOf()`：获取原型
   - `instanceof`：检查原型链
   - `hasOwnProperty()`：检查自身属性

