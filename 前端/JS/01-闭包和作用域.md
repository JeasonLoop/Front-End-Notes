# JavaScript 闭包和作用域

## 1. 作用域（Scope）

### 1.1 什么是作用域

作用域是指变量、函数和对象的可访问性范围。JavaScript 有三种作用域：

```javascript
// 1. 全局作用域
var globalVar = "我是全局变量";

function testFunction() {
  // 2. 函数作用域（局部作用域）
  var localVar = "我是局部变量";
  console.log(globalVar); // 可以访问全局变量
  console.log(localVar);  // 可以访问局部变量
}

testFunction();
console.log(globalVar); // 可以访问
// console.log(localVar); // 报错：localVar is not defined

// 3. 块作用域（ES6+）
if (true) {
  let blockVar = "我是块级变量";
  const blockConst = "我是块级常量";
  console.log(blockVar);   // 可以访问
  console.log(blockConst); // 可以访问
}
// console.log(blockVar);   // 报错：blockVar is not defined
// console.log(blockConst); // 报错：blockConst is not defined
```

### 1.2 var、let、const 的区别

```javascript
// ========== var 的特点 ==========
// 1. 函数作用域，没有块作用域
function varTest() {
  if (true) {
    var x = 1;
  }
  console.log(x); // 1，可以访问
}

// 2. 变量提升（hoisting）
console.log(y); // undefined，不会报错
var y = 2;

// 等价于：
var y;
console.log(y); // undefined
y = 2;

// 3. 可以重复声明
var z = 1;
var z = 2; // 不会报错
console.log(z); // 2

// ========== let 的特点 ==========
// 1. 块作用域
function letTest() {
  if (true) {
    let a = 1;
  }
  // console.log(a); // 报错：a is not defined
}

// 2. 不存在变量提升（暂时性死区）
// console.log(b); // 报错：Cannot access 'b' before initialization
let b = 2;

// 3. 不能重复声明
let c = 1;
// let c = 2; // 报错：Identifier 'c' has already been declared

// ========== const 的特点 ==========
// 1. 块作用域（同 let）
// 2. 必须初始化
// const d; // 报错：Missing initializer in const declaration

// 3. 不能重新赋值
const e = 1;
// e = 2; // 报错：Assignment to constant variable

// 4. 对象和数组可以修改内容（引用不变）
const obj = { name: "John" };
obj.name = "Jane"; // 可以修改
obj.age = 30;      // 可以添加属性
// obj = {};        // 报错：不能重新赋值

const arr = [1, 2, 3];
arr.push(4);       // 可以修改
arr[0] = 0;        // 可以修改
// arr = [];        // 报错：不能重新赋值
```

### 1.3 作用域链

```javascript
// 作用域链：从当前作用域向上查找变量，直到全局作用域
var globalVar = "全局变量";

function outerFunction() {
  var outerVar = "外部变量";

  function innerFunction() {
    var innerVar = "内部变量";

    // 查找顺序：innerVar -> outerVar -> globalVar -> undefined
    console.log(innerVar);  // "内部变量"
    console.log(outerVar);  // "外部变量"
    console.log(globalVar); // "全局变量"
  }

  innerFunction();
}

outerFunction();
```

## 2. 闭包（Closure）

### 2.1 什么是闭包

闭包是指函数能够访问其外部（封闭）作用域中的变量，即使外部函数已经执行完毕。

```javascript
// 基本闭包示例
function outerFunction() {
  var outerVariable = "我在外部函数中";

  // 内部函数形成闭包
  function innerFunction() {
    console.log(outerVariable); // 访问外部变量
  }

  return innerFunction; // 返回内部函数
}

var closure = outerFunction();
closure(); // "我在外部函数中"
// 即使 outerFunction 已经执行完毕，innerFunction 仍然可以访问 outerVariable
```

### 2.2 闭包的形成条件

```javascript
// 条件1：函数嵌套
function outer() {
  var x = 1;

  // 条件2：内部函数引用外部变量
  function inner() {
    console.log(x); // 引用外部变量 x
  }

  // 条件3：内部函数被返回或在外部使用
  return inner;
}

var fn = outer();
fn(); // 1
```

### 2.3 闭包的常见应用

#### 1. 数据私有化（封装）

```javascript
// 使用闭包创建私有变量
function createCounter() {
  // 私有变量，外部无法直接访问
  var count = 0;

  // 返回一个对象，包含访问和修改私有变量的方法
  return {
    // 获取计数值
    getCount: function() {
      return count;
    },
    // 增加计数
    increment: function() {
      count++;
      return count;
    },
    // 减少计数
    decrement: function() {
      count--;
      return count;
    },
    // 重置计数
    reset: function() {
      count = 0;
      return count;
    }
  };
}

var counter = createCounter();
console.log(counter.getCount());    // 0
console.log(counter.increment());   // 1
console.log(counter.increment());   // 2
console.log(counter.decrement());   // 1
console.log(counter.reset());       // 0
// console.log(counter.count);      // undefined，无法直接访问私有变量
```

#### 2. 函数工厂

```javascript
// 创建不同配置的函数
function createMultiplier(multiplier) {
  // multiplier 被闭包保存
  return function(number) {
    return number * multiplier;
  };
}

var double = createMultiplier(2);
var triple = createMultiplier(3);

console.log(double(5));  // 10
console.log(triple(5));  // 15
```

#### 3. 模块模式

```javascript
// 使用闭包实现模块模式
var myModule = (function() {
  // 私有变量和函数
  var privateVariable = "我是私有的";

  function privateFunction() {
    console.log("私有函数");
  }

  // 返回公共接口
  return {
    // 公共方法
    publicMethod: function() {
      console.log("公共方法可以访问：" + privateVariable);
      privateFunction(); // 可以调用私有函数
    },
    // 另一个公共方法
    anotherPublicMethod: function() {
      privateVariable = "被修改了";
    }
  };
})();

myModule.publicMethod();        // 可以访问
// myModule.privateFunction();   // 报错：无法访问私有函数
// console.log(myModule.privateVariable); // undefined
```

### 2.4 闭包与循环

#### 经典问题：循环中的闭包

```javascript
// 问题：所有函数都打印 5
for (var i = 0; i < 5; i++) {
  setTimeout(function() {
    console.log(i); // 打印 5 次 5
  }, 100);
}

// 原因：var 是函数作用域，所有 setTimeout 回调共享同一个 i
// 当回调执行时，循环已经结束，i 的值是 5
```

#### 解决方案1：使用 IIFE（立即执行函数表达式）

```javascript
// 使用 IIFE 创建新的作用域
for (var i = 0; i < 5; i++) {
  (function(j) {
    // j 是 IIFE 的参数，每次循环都有独立的值
    setTimeout(function() {
      console.log(j); // 打印 0, 1, 2, 3, 4
    }, 100);
  })(i); // 立即执行，传入当前的 i 值
}
```

#### 解决方案2：使用 let（推荐）

```javascript
// let 是块作用域，每次循环都创建新的绑定
for (let i = 0; i < 5; i++) {
  setTimeout(function() {
    console.log(i); // 打印 0, 1, 2, 3, 4
  }, 100);
}
```

#### 解决方案3：使用 bind

```javascript
for (var i = 0; i < 5; i++) {
  setTimeout(function(j) {
    console.log(j); // 打印 0, 1, 2, 3, 4
  }.bind(null, i), 100);
}
```

### 2.5 闭包的注意事项

#### 1. 内存泄漏

```javascript
// 闭包可能导致内存泄漏
function attachHandlers() {
  var largeData = new Array(1000000).fill("data");

  document.getElementById("button").onclick = function() {
    // 这个函数持有 largeData 的引用，即使不再需要
    console.log("Button clicked");
    // largeData 无法被垃圾回收
  };

  // 即使 largeData 不再需要，但由于闭包引用，无法释放内存
}

// 解决方案：在不需要时清除引用
function attachHandlersFixed() {
  var largeData = new Array(1000000).fill("data");

  document.getElementById("button").onclick = function() {
    console.log("Button clicked");
  };

  // 清除引用
  largeData = null;
}
```

#### 2. 性能考虑

```javascript
// 闭包会创建额外的内存开销
function createFunctions() {
  var result = [];

  for (var i = 0; i < 1000; i++) {
    // 每个函数都创建一个闭包，占用内存
    result[i] = function() {
      return i;
    };
  }

  return result;
}

// 优化：只在必要时使用闭包
function createFunctionsOptimized() {
  var result = [];

  for (var i = 0; i < 1000; i++) {
    // 如果不需要访问外部变量，不要创建闭包
    result[i] = (function(j) {
      return function() {
        return j; // 只访问必要的变量
      };
    })(i);
  }

  return result;
}
```

## 3. 变量提升（Hoisting）

### 3.1 var 的变量提升

```javascript
// 变量声明会被提升到作用域顶部
console.log(x); // undefined，不会报错
var x = 5;
console.log(x); // 5

// 等价于：
var x;           // 声明提升
console.log(x);  // undefined
x = 5;           // 赋值不提升
console.log(x);  // 5
```

### 3.2 函数提升

```javascript
// 函数声明会被完全提升
sayHello(); // "Hello"，可以调用

function sayHello() {
  console.log("Hello");
}

// 函数表达式不会被提升
// sayGoodbye(); // 报错：sayGoodbye is not a function

var sayGoodbye = function() {
  console.log("Goodbye");
};

sayGoodbye(); // "Goodbye"，现在可以调用
```

### 3.3 let 和 const 的暂时性死区（TDZ）

```javascript
// let 和 const 存在暂时性死区
// 在声明之前访问会报错

// console.log(a); // 报错：Cannot access 'a' before initialization
let a = 1;

// console.log(b); // 报错：Cannot access 'b' before initialization
const b = 2;

// 即使 typeof 也不安全
// typeof c; // 报错：Cannot access 'c' before initialization
let c = 3;
```

## 4. 实际应用示例

### 4.1 防抖（Debounce）

```javascript
/**
 * 防抖函数：在事件触发 n 秒后才执行，如果在这 n 秒内再次触发，则重新计时
 * @param {Function} func 要防抖的函数
 * @param {number} wait 等待时间（毫秒）
 * @returns {Function} 防抖后的函数
 */
function debounce(func, wait) {
  var timeout; // 闭包保存定时器 ID

  return function() {
    var context = this;      // 保存 this 上下文
    var args = arguments;    // 保存参数

    // 清除之前的定时器
    clearTimeout(timeout);

    // 设置新的定时器
    timeout = setTimeout(function() {
      func.apply(context, args); // 执行原函数
    }, wait);
  };
}

// 使用示例
var searchInput = document.getElementById("search");
var debouncedSearch = debounce(function(query) {
  console.log("搜索：" + query);
  // 执行搜索操作
}, 300);

searchInput.addEventListener("input", function(e) {
  debouncedSearch(e.target.value);
});
```

### 4.2 节流（Throttle）

```javascript
/**
 * 节流函数：在 n 秒内只执行一次函数
 * @param {Function} func 要节流的函数
 * @param {number} wait 时间间隔（毫秒）
 * @returns {Function} 节流后的函数
 */
function throttle(func, wait) {
  var lastTime = 0; // 闭包保存上次执行时间

  return function() {
    var context = this;
    var args = arguments;
    var now = Date.now();

    // 如果距离上次执行时间超过 wait，则执行
    if (now - lastTime >= wait) {
      lastTime = now;
      func.apply(context, args);
    }
  };
}

// 使用示例
var scrollHandler = throttle(function() {
  console.log("滚动事件");
  // 处理滚动逻辑
}, 200);

window.addEventListener("scroll", scrollHandler);
```

### 4.3 单例模式

```javascript
/**
 * 使用闭包实现单例模式
 */
var Singleton = (function() {
  var instance; // 私有变量，保存唯一实例

  function createInstance() {
    // 创建实例的逻辑
    return {
      name: "Singleton Instance",
      getData: function() {
        return "Some data";
      }
    };
  }

  return {
    // 获取单例实例
    getInstance: function() {
      if (!instance) {
        instance = createInstance();
      }
      return instance;
    }
  };
})();

var instance1 = Singleton.getInstance();
var instance2 = Singleton.getInstance();
console.log(instance1 === instance2); // true，同一个实例
```

## 5. 总结

### 关键点：

1. **作用域**：决定变量的可访问性
   - 全局作用域、函数作用域、块作用域
   - var 是函数作用域，let/const 是块作用域

2. **闭包**：函数能够访问外部作用域的变量
   - 形成条件：函数嵌套、内部函数引用外部变量、内部函数被外部使用
   - 应用：数据私有化、函数工厂、模块模式

3. **变量提升**：
   - var 和 function 声明会被提升
   - let/const 存在暂时性死区

4. **注意事项**：
   - 闭包可能导致内存泄漏
   - 循环中使用闭包要注意变量绑定
   - 合理使用闭包，避免不必要的内存占用

