# JavaScript 错误处理和调试

## 1. 错误类型

### 1.1 JavaScript 错误类型

```javascript
/**
 * JavaScript 有 7 种错误类型：
 * 1. Error：基础错误类型
 * 2. SyntaxError：语法错误
 * 3. ReferenceError：引用错误
 * 4. TypeError：类型错误
 * 5. RangeError：范围错误
 * 6. URIError：URI 错误
 * 7. EvalError：eval 错误（已废弃）
 */

// 1. SyntaxError：语法错误
// var x = ; // 语法错误

// 2. ReferenceError：引用未定义的变量
// console.log(undefinedVar); // ReferenceError

// 3. TypeError：类型错误
var obj = null;
// obj.method(); // TypeError: Cannot read property 'method' of null

// 4. RangeError：数值超出范围
// var arr = new Array(-1); // RangeError

// 5. URIError：URI 处理错误
// decodeURIComponent("%"); // URIError

// 6. Error：通用错误
throw new Error("Something went wrong");
```

### 1.2 自定义错误

```javascript
/**
 * 创建自定义错误类型
 */

// 继承 Error
function ValidationError(message) {
  this.name = "ValidationError";
  this.message = message;
  this.stack = (new Error()).stack;
}

ValidationError.prototype = Object.create(Error.prototype);
ValidationError.prototype.constructor = ValidationError;

// 使用
try {
  throw new ValidationError("Invalid input");
} catch (error) {
  if (error instanceof ValidationError) {
    console.log("Validation error:", error.message);
  }
}

// ES6 Class 方式
class CustomError extends Error {
  constructor(message, code) {
    super(message);
    this.name = "CustomError";
    this.code = code;
  }
}

throw new CustomError("Custom error", "ERR001");
```

## 2. 错误处理

### 2.1 try-catch-finally

```javascript
/**
 * try-catch-finally：捕获和处理错误
 */

try {
  // 可能出错的代码
  var result = riskyOperation();
  console.log("Success:", result);
} catch (error) {
  // 处理错误
  console.error("Error:", error.message);
  console.error("Stack:", error.stack);
} finally {
  // 无论是否出错都执行
  console.log("Cleanup");
}

// 嵌套 try-catch
try {
  try {
    throw new Error("Inner error");
  } catch (innerError) {
    console.log("Caught inner error:", innerError.message);
    throw new Error("Outer error"); // 重新抛出
  }
} catch (outerError) {
  console.log("Caught outer error:", outerError.message);
}
```

### 2.2 错误对象属性

```javascript
/**
 * Error 对象属性
 */

try {
  throw new Error("Test error");
} catch (error) {
  console.log(error.name);     // "Error"（错误类型）
  console.log(error.message);  // "Test error"（错误消息）
  console.log(error.stack);    // 堆栈跟踪
  console.log(error.fileName); // 文件名（Firefox）
  console.log(error.lineNumber); // 行号（Firefox）
  console.log(error.columnNumber); // 列号（Firefox）
}
```

### 2.3 异步错误处理

#### Promise 错误处理

```javascript
/**
 * Promise 错误处理
 */

// 使用 catch
fetch("/api/data")
  .then(function(response) {
    return response.json();
  })
  .catch(function(error) {
    console.error("Error:", error);
  });

// 使用 try-catch（async/await）
async function fetchData() {
  try {
    var response = await fetch("/api/data");
    var data = await response.json();
    return data;
  } catch (error) {
    console.error("Error:", error);
    throw error; // 重新抛出
  }
}

// Promise.all 错误处理
Promise.all([
  fetch("/api/1"),
  fetch("/api/2"),
  fetch("/api/3")
])
  .then(function(responses) {
    // 所有成功
  })
  .catch(function(error) {
    // 任何一个失败
    console.error("One or more requests failed:", error);
  });

// Promise.allSettled：等待所有完成
Promise.allSettled([
  fetch("/api/1"),
  fetch("/api/2"),
  fetch("/api/3")
])
  .then(function(results) {
    results.forEach(function(result, index) {
      if (result.status === "fulfilled") {
        console.log(`Request ${index} succeeded`);
      } else {
        console.log(`Request ${index} failed:`, result.reason);
      }
    });
  });
```

#### 回调函数错误处理

```javascript
/**
 * 回调函数错误处理（Node.js 风格）
 */

function asyncOperation(callback) {
  setTimeout(function() {
    var random = Math.random();
    if (random > 0.5) {
      callback(null, "Success"); // 错误优先
    } else {
      callback(new Error("Operation failed"), null);
    }
  }, 1000);
}

asyncOperation(function(error, result) {
  if (error) {
    console.error("Error:", error.message);
    return;
  }
  console.log("Result:", result);
});
```

### 2.4 全局错误处理

```javascript
/**
 * 全局错误处理
 */

// window.onerror：捕获未处理的错误
window.onerror = function(message, source, lineno, colno, error) {
  console.error("Global error:", {
    message: message,
    source: source,
    line: lineno,
    column: colno,
    error: error
  });

  // 发送错误到服务器
  sendErrorToServer({
    message: message,
    source: source,
    line: lineno,
    column: colno,
    stack: error.stack
  });

  return true; // 阻止默认错误处理
};

// unhandledrejection：捕获未处理的 Promise 拒绝
window.addEventListener("unhandledrejection", function(event) {
  console.error("Unhandled promise rejection:", event.reason);

  // 发送错误到服务器
  sendErrorToServer({
    type: "unhandledrejection",
    reason: event.reason,
    promise: event.promise
  });

  event.preventDefault(); // 阻止默认行为
});

// 发送错误到服务器
function sendErrorToServer(errorInfo) {
  fetch("/api/errors", {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify(errorInfo)
  }).catch(function(err) {
    console.error("Failed to send error:", err);
  });
}
```

## 3. 调试技巧

### 3.1 console 方法

```javascript
/**
 * console 调试方法
 */

// console.log：基本输出
console.log("Message", { key: "value" });

// console.error：错误输出（红色）
console.error("Error message");

// console.warn：警告输出（黄色）
console.warn("Warning message");

// console.info：信息输出
console.info("Info message");

// console.debug：调试输出
console.debug("Debug message");

// console.table：表格输出
console.table([
  { name: "John", age: 30 },
  { name: "Jane", age: 25 }
]);

// console.group：分组输出
console.group("Group 1");
console.log("Item 1");
console.log("Item 2");
console.groupEnd();

// console.time：计时
console.time("operation");
// 执行操作
console.timeEnd("operation"); // operation: 123.456ms

// console.trace：堆栈跟踪
function functionA() {
  functionB();
}

function functionB() {
  console.trace("Trace");
}
functionA();

// console.assert：断言
console.assert(1 === 2, "1 is not equal to 2");

// console.count：计数
console.count("counter"); // counter: 1
console.count("counter"); // counter: 2
console.countReset("counter"); // 重置计数
```

### 3.2 debugger 语句

```javascript
/**
 * debugger：断点调试
 */

function complexFunction() {
  var x = 10;
  var y = 20;

  debugger; // 浏览器会在此暂停

  var result = x + y;
  return result;
}

complexFunction();
```

### 3.3 条件断点

```javascript
/**
 * 在浏览器 DevTools 中设置条件断点
 * 右键点击行号 -> Add conditional breakpoint
 */

function processItems(items) {
  for (var i = 0; i < items.length; i++) {
    var item = items[i];
    // 条件：i === 5 时暂停
    console.log(item);
  }
}
```

### 3.4 性能分析

```javascript
/**
 * 性能分析
 */

// Performance API
var startTime = performance.now();

// 执行操作
for (var i = 0; i < 1000000; i++) {
  // 一些操作
}

var endTime = performance.now();
console.log("Duration:", endTime - startTime, "ms");

// 标记和测量
performance.mark("start");
// 操作
performance.mark("end");
performance.measure("operation", "start", "end");
var measure = performance.getEntriesByName("operation")[0];
console.log("Duration:", measure.duration, "ms");
```

## 4. 错误处理最佳实践

### 4.1 错误处理策略

```javascript
/**
 * 错误处理策略
 */

// 1. 尽早捕获错误
function processData(data) {
  if (!data) {
    throw new Error("Data is required");
  }

  if (!Array.isArray(data)) {
    throw new TypeError("Data must be an array");
  }

  // 处理数据
  return data.map(function(item) {
    return item * 2;
  });
}

// 2. 提供有意义的错误消息
function divide(a, b) {
  if (b === 0) {
    throw new Error("Division by zero is not allowed");
  }
  return a / b;
}

// 3. 记录错误信息
function logError(error, context) {
  console.error("Error occurred:", {
    message: error.message,
    stack: error.stack,
    context: context,
    timestamp: new Date().toISOString()
  });

  // 发送到错误监控服务
  sendToErrorService({
    error: error.message,
    stack: error.stack,
    context: context
  });
}

// 4. 优雅降级
function loadData() {
  try {
    return fetch("/api/data").then(function(response) {
      return response.json();
    });
  } catch (error) {
    console.error("Failed to load data:", error);
    // 返回默认值
    return Promise.resolve([]);
  }
}
```

### 4.2 错误边界（React）

```javascript
/**
 * React 错误边界示例
 */

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true, error: error };
  }

  componentDidCatch(error, errorInfo) {
    // 记录错误
    console.error("Error caught by boundary:", error, errorInfo);
    // 发送到错误服务
    logErrorToService(error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return <h1>Something went wrong.</h1>;
    }
    return this.props.children;
  }
}

// 使用
<ErrorBoundary>
  <App />
</ErrorBoundary>
```

### 4.3 错误监控服务

```javascript
/**
 * 集成错误监控服务（如 Sentry）
 */

// 初始化 Sentry
Sentry.init({
  dsn: "your-dsn",
  environment: "production",
  beforeSend: function(event, hint) {
    // 过滤敏感信息
    if (event.user) {
      delete event.user.email;
    }
    return event;
  }
});

// 捕获错误
try {
  riskyOperation();
} catch (error) {
  Sentry.captureException(error);
}

// 添加上下文
Sentry.setUser({ id: "123", username: "john" });
Sentry.setTag("page", "checkout");
Sentry.setContext("order", { id: "456", total: 100 });
```

## 5. 调试工具

### 5.1 Chrome DevTools

```javascript
/**
 * Chrome DevTools 使用技巧
 */

// 1. Sources 面板：设置断点
// 2. Console 面板：执行代码
// 3. Network 面板：查看网络请求
// 4. Performance 面板：性能分析
// 5. Memory 面板：内存分析

// 使用 $0-$4 引用最近选择的元素
// $0：最近选择的元素
// $1：倒数第二个选择的元素
// ...

// 使用 $_ 引用最后一个表达式的结果
console.log("test");
console.log($_); // "test"
```

### 5.2 VS Code 调试

```json
/**
 * .vscode/launch.json
 * VS Code 调试配置
 */
{
  "version": "0.2.0",
  "configurations": [
    {
      "type": "node",
      "request": "launch",
      "name": "Debug Node",
      "program": "${workspaceFolder}/index.js",
      "skipFiles": ["<node_internals>/**"]
    },
    {
      "type": "chrome",
      "request": "launch",
      "name": "Debug Chrome",
      "url": "http://localhost:3000",
      "webRoot": "${workspaceFolder}"
    }
  ]
}
```

## 6. 实际应用示例

### 6.1 错误处理工具函数

```javascript
/**
 * 错误处理工具函数
 */

var ErrorHandler = {
  // 安全执行函数
  safeExecute: function(fn, defaultValue) {
    try {
      return fn();
    } catch (error) {
      console.error("Error in safeExecute:", error);
      return defaultValue;
    }
  },

  // 重试机制
  retry: function(fn, maxRetries, delay) {
    var self = this;
    return new Promise(function(resolve, reject) {
      function attempt(retriesLeft) {
        fn()
          .then(resolve)
          .catch(function(error) {
            if (retriesLeft > 0) {
              console.log(`Retrying... ${retriesLeft} attempts left`);
              setTimeout(function() {
                attempt(retriesLeft - 1);
              }, delay);
            } else {
              reject(error);
            }
          });
      }
      attempt(maxRetries);
    });
  },

  // 超时包装
  withTimeout: function(promise, timeout) {
    return Promise.race([
      promise,
      new Promise(function(_, reject) {
        setTimeout(function() {
          reject(new Error("Operation timed out"));
        }, timeout);
      })
    ]);
  }
};

// 使用
ErrorHandler.safeExecute(function() {
  return riskyOperation();
}, "default value");

ErrorHandler.retry(function() {
  return fetch("/api/data");
}, 3, 1000);

ErrorHandler.withTimeout(fetch("/api/data"), 5000);
```

### 6.2 错误日志系统

```javascript
/**
 * 错误日志系统
 */

var ErrorLogger = {
  logs: [],

  log: function(error, context) {
    var logEntry = {
      timestamp: new Date().toISOString(),
      message: error.message,
      stack: error.stack,
      context: context,
      userAgent: navigator.userAgent,
      url: window.location.href
    };

    this.logs.push(logEntry);

    // 保存到 localStorage
    try {
      var storedLogs = JSON.parse(localStorage.getItem("errorLogs") || "[]");
      storedLogs.push(logEntry);
      localStorage.setItem("errorLogs", JSON.stringify(storedLogs.slice(-100))); // 保留最近100条
    } catch (e) {
      console.error("Failed to save error log:", e);
    }

    // 发送到服务器
    this.sendToServer(logEntry);
  },

  sendToServer: function(logEntry) {
    if (navigator.onLine) {
      fetch("/api/errors", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(logEntry)
      }).catch(function(err) {
        console.error("Failed to send error log:", err);
      });
    }
  },

  getLogs: function() {
    return this.logs;
  },

  clearLogs: function() {
    this.logs = [];
    localStorage.removeItem("errorLogs");
  }
};

// 全局错误处理
window.addEventListener("error", function(event) {
  ErrorLogger.log(event.error, {
    filename: event.filename,
    lineno: event.lineno,
    colno: event.colno
  });
});

window.addEventListener("unhandledrejection", function(event) {
  ErrorLogger.log(event.reason, {
    type: "unhandledrejection"
  });
});
```

## 7. 总结

### 关键点：

1. **错误类型**：
   - Error、SyntaxError、ReferenceError、TypeError 等
   - 创建自定义错误类型

2. **错误处理**：
   - try-catch-finally
   - Promise catch
   - async/await try-catch
   - 全局错误处理

3. **调试技巧**：
   - console 方法
   - debugger 语句
   - 浏览器 DevTools
   - 性能分析

4. **最佳实践**：
   - 尽早捕获错误
   - 提供有意义的错误消息
   - 记录错误信息
   - 优雅降级
   - 集成错误监控服务

5. **工具**：
   - Chrome DevTools
   - VS Code 调试器
   - 错误监控服务（Sentry）
   - 性能分析工具

良好的错误处理和调试能力是开发高质量应用的关键。

