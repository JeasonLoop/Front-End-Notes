# JavaScript 元编程和反射

## 1. 什么是元编程

元编程（Metaprogramming）是指编写能够操作其他程序的程序，或者编写能够操作自身的程序。

```javascript
/**
 * JavaScript 的元编程能力：
 * - 反射：检查代码结构
 * - 代理：拦截和修改操作
 * - 符号：元数据编程
 */

// 反射示例：检查对象属性
var obj = { name: "John", age: 30 };
console.log(Object.keys(obj));           // ["name", "age"]
console.log(Object.getOwnPropertyNames(obj)); // ["name", "age"]
```

## 2. Proxy（代理）

### 2.1 Proxy 基础

```javascript
/**
 * Proxy：创建一个对象的代理，拦截对象操作
 * new Proxy(target, handler)
 */

var target = {
  name: "John",
  age: 30
};

// 创建代理
var proxy = new Proxy(target, {
  // 拦截属性读取
  get: function(target, prop, receiver) {
    console.log(`读取属性: ${prop}`);
    return target[prop];
  },

  // 拦截属性设置
  set: function(target, prop, value, receiver) {
    console.log(`设置属性: ${prop} = ${value}`);
    target[prop] = value;
    return true; // 表示设置成功
  },

  // 拦截属性检查
  has: function(target, prop) {
    console.log(`检查属性: ${prop}`);
    return prop in target;
  },

  // 拦截删除操作
  deleteProperty: function(target, prop) {
    console.log(`删除属性: ${prop}`);
    delete target[prop];
    return true;
  }
});

// 使用代理
proxy.name;           // "读取属性: name" -> "John"
proxy.age = 31;       // "设置属性: age = 31"
"name" in proxy;      // "检查属性: name" -> true
delete proxy.age;     // "删除属性: age"
```

### 2.2 Proxy 陷阱（Traps）

```javascript
/**
 * Proxy 支持多种陷阱（拦截器）
 */

var target = {};

var proxy = new Proxy(target, {
  // get：拦截属性读取
  get: function(target, prop, receiver) {
    if (prop === "secret") {
      return "Access Denied";
    }
    return Reflect.get(target, prop, receiver);
  },

  // set：拦截属性设置
  set: function(target, prop, value, receiver) {
    if (prop === "age" && (value < 0 || value > 150)) {
      throw new Error("Invalid age");
    }
    return Reflect.set(target, prop, value, receiver);
  },

  // has：拦截 in 操作符
  has: function(target, prop) {
    if (prop.startsWith("_")) {
      return false; // 隐藏私有属性
    }
    return Reflect.has(target, prop);
  },

  // deleteProperty：拦截 delete 操作
  deleteProperty: function(target, prop) {
    if (prop.startsWith("_")) {
      throw new Error("Cannot delete private property");
    }
    return Reflect.deleteProperty(target, prop);
  },

  // ownKeys：拦截 Object.keys() 等
  ownKeys: function(target) {
    return Reflect.ownKeys(target).filter(function(key) {
      return !key.toString().startsWith("_");
    });
  },

  // getOwnPropertyDescriptor：拦截属性描述符获取
  getOwnPropertyDescriptor: function(target, prop) {
    if (prop.startsWith("_")) {
      return undefined; // 隐藏私有属性
    }
    return Reflect.getOwnPropertyDescriptor(target, prop);
  },

  // defineProperty：拦截属性定义
  defineProperty: function(target, prop, descriptor) {
    if (prop.startsWith("_")) {
      throw new Error("Cannot define private property");
    }
    return Reflect.defineProperty(target, prop, descriptor);
  },

  // preventExtensions：拦截 Object.preventExtensions()
  preventExtensions: function(target) {
    return false; // 不允许阻止扩展
  },

  // isExtensible：拦截 Object.isExtensible()
  isExtensible: function(target) {
    return true; // 总是可扩展
  },

  // getPrototypeOf：拦截 Object.getPrototypeOf()
  getPrototypeOf: function(target) {
    return Reflect.getPrototypeOf(target);
  },

  // setPrototypeOf：拦截 Object.setPrototypeOf()
  setPrototypeOf: function(target, proto) {
    throw new Error("Cannot change prototype");
  },

  // apply：拦截函数调用（target 必须是函数）
  apply: function(target, thisArg, argumentsList) {
    console.log("函数被调用，参数：", argumentsList);
    return Reflect.apply(target, thisArg, argumentsList);
  },

  // construct：拦截 new 操作（target 必须是构造函数）
  construct: function(target, argumentsList, newTarget) {
    console.log("构造函数被调用，参数：", argumentsList);
    return Reflect.construct(target, argumentsList, newTarget);
  }
});

// 使用示例
proxy.name = "John";
proxy._private = "secret";
console.log("name" in proxy);     // true
console.log("_private" in proxy); // false（被隐藏）
```

### 2.3 Proxy 实际应用

#### 1. 数据验证

```javascript
/**
 * 使用 Proxy 实现数据验证
 */

function createValidatedObject(schema) {
  return new Proxy({}, {
    set: function(target, prop, value) {
      // 检查属性是否在 schema 中定义
      if (!(prop in schema)) {
        throw new Error(`Property ${prop} is not defined in schema`);
      }

      // 验证值类型
      var expectedType = schema[prop].type;
      var actualType = typeof value;
      if (actualType !== expectedType) {
        throw new Error(`Property ${prop} must be of type ${expectedType}`);
      }

      // 执行自定义验证
      if (schema[prop].validate) {
        if (!schema[prop].validate(value)) {
          throw new Error(`Property ${prop} validation failed`);
        }
      }

      target[prop] = value;
      return true;
    }
  });
}

// 使用
var schema = {
  name: {
    type: "string",
    validate: function(value) {
      return value.length > 0;
    }
  },
  age: {
    type: "number",
    validate: function(value) {
      return value >= 0 && value <= 150;
    }
  }
};

var user = createValidatedObject(schema);
user.name = "John";  // 成功
user.age = 30;       // 成功
// user.age = -1;    // 报错：验证失败
// user.name = 123;  // 报错：类型错误
```

#### 2. 属性访问日志

```javascript
/**
 * 使用 Proxy 记录属性访问
 */

function createLoggedObject(obj) {
  return new Proxy(obj, {
    get: function(target, prop) {
      console.log(`[GET] ${prop}`);
      return target[prop];
    },
    set: function(target, prop, value) {
      console.log(`[SET] ${prop} = ${value}`);
      target[prop] = value;
      return true;
    }
  });
}

var obj = createLoggedObject({ name: "John" });
obj.name;        // [GET] name
obj.age = 30;    // [SET] age = 30
```

#### 3. 负索引数组

```javascript
/**
 * 使用 Proxy 实现负索引数组
 */

function createNegativeArray(arr) {
  return new Proxy(arr, {
    get: function(target, prop, receiver) {
      var index = Number(prop);
      if (index < 0) {
        index = target.length + index;
      }
      return target[index];
    }
  });
}

var arr = createNegativeArray([1, 2, 3, 4, 5]);
console.log(arr[-1]); // 5（最后一个元素）
console.log(arr[-2]); // 4（倒数第二个元素）
```

## 3. Reflect（反射）

### 3.1 Reflect 基础

```javascript
/**
 * Reflect：提供对象操作的默认行为
 * 与 Proxy 配合使用，提供元编程能力
 */

var obj = {
  name: "John",
  age: 30
};

// Reflect.get：获取属性值
console.log(Reflect.get(obj, "name")); // "John"

// Reflect.set：设置属性值
Reflect.set(obj, "age", 31);
console.log(obj.age); // 31

// Reflect.has：检查属性是否存在
console.log(Reflect.has(obj, "name")); // true

// Reflect.deleteProperty：删除属性
Reflect.deleteProperty(obj, "age");
console.log("age" in obj); // false

// Reflect.ownKeys：获取所有属性键
console.log(Reflect.ownKeys(obj)); // ["name"]

// Reflect.defineProperty：定义属性
Reflect.defineProperty(obj, "city", {
  value: "New York",
  writable: true,
  enumerable: true,
  configurable: true
});

// Reflect.getOwnPropertyDescriptor：获取属性描述符
var desc = Reflect.getOwnPropertyDescriptor(obj, "name");
console.log(desc); // { value: "John", writable: true, enumerable: true, configurable: true }

// Reflect.preventExtensions：阻止扩展
Reflect.preventExtensions(obj);
// obj.newProp = "value"; // 报错：Cannot add property

// Reflect.isExtensible：检查是否可扩展
console.log(Reflect.isExtensible(obj)); // false

// Reflect.getPrototypeOf：获取原型
console.log(Reflect.getPrototypeOf(obj)); // Object.prototype

// Reflect.setPrototypeOf：设置原型
var proto = { type: "object" };
Reflect.setPrototypeOf(obj, proto);
console.log(obj.type); // "object"
```

### 3.2 Reflect 与 Proxy 配合

```javascript
/**
 * Reflect 在 Proxy 中的使用
 * 提供默认行为，可以在此基础上修改
 */

var target = { name: "John" };

var proxy = new Proxy(target, {
  get: function(target, prop, receiver) {
    // 使用 Reflect 获取默认行为
    var value = Reflect.get(target, prop, receiver);

    // 添加自定义逻辑
    if (typeof value === "string") {
      return value.toUpperCase();
    }

    return value;
  },

  set: function(target, prop, value, receiver) {
    // 添加验证逻辑
    if (prop === "age" && (value < 0 || value > 150)) {
      throw new Error("Invalid age");
    }

    // 使用 Reflect 执行默认行为
    return Reflect.set(target, prop, value, receiver);
  }
});

console.log(proxy.name); // "JOHN"（转换为大写）
proxy.age = 30;          // 成功
// proxy.age = 200;      // 报错：Invalid age
```

## 4. Symbol（符号）

### 4.1 Symbol 作为元数据

```javascript
/**
 * Symbol 用于添加元数据，不会影响原有属性
 */

// 创建 Symbol
var ID = Symbol("id");
var TYPE = Symbol("type");

var obj = {
  name: "John",
  [ID]: 12345,
  [TYPE]: "user"
};

// Symbol 属性不会被枚举
console.log(Object.keys(obj));        // ["name"]
console.log(Object.getOwnPropertySymbols(obj)); // [Symbol(id), Symbol(type)]

// 访问 Symbol 属性
console.log(obj[ID]);   // 12345
console.log(obj[TYPE]); // "user"
```

### 4.2 内置 Symbol

```javascript
/**
 * 内置 Symbol：用于自定义对象行为
 */

// Symbol.iterator：定义迭代器
var myIterable = {
  [Symbol.iterator]: function* () {
    yield 1;
    yield 2;
    yield 3;
  }
};

console.log([...myIterable]); // [1, 2, 3]

// Symbol.toStringTag：自定义 toString 标签
var obj = {
  [Symbol.toStringTag]: "MyObject"
};
console.log(obj.toString()); // "[object MyObject]"

// Symbol.toPrimitive：自定义类型转换
var obj = {
  [Symbol.toPrimitive]: function(hint) {
    if (hint === "number") {
      return 42;
    }
    if (hint === "string") {
      return "forty-two";
    }
    return true;
  }
};

console.log(+obj);      // 42（数字转换）
console.log(String(obj)); // "forty-two"（字符串转换）
console.log(!!obj);     // true（布尔转换）

// Symbol.hasInstance：自定义 instanceof
class MyArray {
  static [Symbol.hasInstance](instance) {
    return Array.isArray(instance);
  }
}

console.log([] instanceof MyArray); // true
console.log({} instanceof MyArray); // false
```

## 5. 装饰器（Decorators）

### 5.1 类装饰器

```javascript
/**
 * 装饰器：修改类或方法的行为
 * 需要 Babel 或 TypeScript 支持
 */

// 类装饰器
function sealed(target) {
  Object.seal(target);
  Object.seal(target.prototype);
}

@sealed
class MyClass {
  method() {
    return "Hello";
  }
}

// 方法装饰器
function readonly(target, propertyKey, descriptor) {
  descriptor.writable = false;
  return descriptor;
}

class Person {
  @readonly
  name() {
    return "John";
  }
}

var person = new Person();
// person.name = function() { return "Jane"; }; // 报错：只读
```

### 5.2 属性装饰器

```javascript
/**
 * 属性装饰器：修改属性行为
 */

function log(target, propertyKey) {
  var value;

  var getter = function() {
    console.log(`Get ${propertyKey}`);
    return value;
  };

  var setter = function(newVal) {
    console.log(`Set ${propertyKey} = ${newVal}`);
    value = newVal;
  };

  Object.defineProperty(target, propertyKey, {
    get: getter,
    set: setter,
    enumerable: true,
    configurable: true
  });
}

class User {
  @log
  name;
}

var user = new User();
user.name = "John"; // "Set name = John"
console.log(user.name); // "Get name" -> "John"
```

## 6. 实际应用示例

### 6.1 响应式数据

```javascript
/**
 * 使用 Proxy 实现响应式数据（类似 Vue）
 */

function reactive(target) {
  var handlers = [];

  var proxy = new Proxy(target, {
    get: function(target, prop) {
      return Reflect.get(target, prop);
    },
    set: function(target, prop, value) {
      var oldValue = target[prop];
      var result = Reflect.set(target, prop, value);

      // 触发更新
      if (oldValue !== value) {
        handlers.forEach(function(handler) {
          handler(prop, value, oldValue);
        });
      }

      return result;
    }
  });

  // 添加监听器
  proxy.$watch = function(handler) {
    handlers.push(handler);
  };

  return proxy;
}

// 使用
var data = reactive({ name: "John", age: 30 });

data.$watch(function(prop, newValue, oldValue) {
  console.log(`${prop} changed from ${oldValue} to ${newValue}`);
});

data.name = "Jane"; // "name changed from John to Jane"
data.age = 31;      // "age changed from 30 to 31"
```

### 6.2 函数调用追踪

```javascript
/**
 * 使用 Proxy 追踪函数调用
 */

function trace(fn) {
  return new Proxy(fn, {
    apply: function(target, thisArg, argumentsList) {
      console.log(`调用函数: ${target.name}`);
      console.log(`参数:`, argumentsList);
      var result = Reflect.apply(target, thisArg, argumentsList);
      console.log(`返回值:`, result);
      return result;
    }
  });
}

function add(a, b) {
  return a + b;
}

var tracedAdd = trace(add);
tracedAdd(2, 3);
// 输出：
// 调用函数: add
// 参数: [2, 3]
// 返回值: 5
```

## 7. 总结

### 关键点：

1. **Proxy**：
   - 拦截对象操作
   - 多种陷阱（traps）
   - 实现数据验证、日志、响应式等

2. **Reflect**：
   - 提供对象操作的默认行为
   - 与 Proxy 配合使用
   - 更安全的对象操作

3. **Symbol**：
   - 唯一标识符
   - 元数据编程
   - 内置 Symbol 自定义行为

4. **装饰器**：
   - 修改类或方法行为
   - 需要转译器支持
   - 提供 AOP 能力

5. **应用场景**：
   - 数据验证
   - 响应式系统
   - 日志记录
   - 性能监控
   - 权限控制

元编程让 JavaScript 更强大，但也增加了复杂性，需要谨慎使用。

