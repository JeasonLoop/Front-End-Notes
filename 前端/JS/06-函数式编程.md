# JavaScript 函数式编程

## 1. 函数式编程基础

### 1.1 什么是函数式编程

函数式编程（FP）是一种编程范式，强调：
- 纯函数
- 不可变性
- 函数组合
- 避免副作用

```javascript
/**
 * 命令式编程（如何做）
 */
var numbers = [1, 2, 3, 4, 5];
var doubled = [];
for (var i = 0; i < numbers.length; i++) {
  doubled.push(numbers[i] * 2);
}

/**
 * 函数式编程（做什么）
 */
var numbers = [1, 2, 3, 4, 5];
var doubled = numbers.map(function(n) {
  return n * 2;
});
```

### 1.2 纯函数（Pure Functions）

```javascript
/**
 * 纯函数：相同输入总是产生相同输出，没有副作用
 */

// 纯函数示例
function add(a, b) {
  return a + b; // 只依赖参数，没有副作用
}

console.log(add(2, 3)); // 5（总是相同）

// 非纯函数示例
var counter = 0;
function impureAdd(a, b) {
  counter++; // 副作用：修改外部变量
  return a + b;
}

// 非纯函数：依赖外部变量
var multiplier = 2;
function multiply(x) {
  return x * multiplier; // 依赖外部变量
}

// 非纯函数：修改输入参数
function addToArray(arr, item) {
  arr.push(item); // 副作用：修改输入参数
  return arr;
}

// 纯函数版本
function addToArrayPure(arr, item) {
  return arr.concat(item); // 返回新数组，不修改原数组
}
```

### 1.3 不可变性（Immutability）

```javascript
/**
 * 不可变性：不修改原数据，而是创建新数据
 */

// 可变操作（不推荐）
var arr = [1, 2, 3];
arr.push(4); // 修改原数组
console.log(arr); // [1, 2, 3, 4]

// 不可变操作（推荐）
var arr = [1, 2, 3];
var newArr = arr.concat(4); // 创建新数组
console.log(arr);    // [1, 2, 3]（原数组不变）
console.log(newArr); // [1, 2, 3, 4]

// 对象不可变操作
var obj = { name: "John", age: 30 };
// 错误方式：obj.age = 31; // 修改原对象

// 正确方式：创建新对象
var newObj = Object.assign({}, obj, { age: 31 });
// 或使用扩展运算符（ES6）
var newObj2 = { ...obj, age: 31 };
```

## 2. 高阶函数（Higher-Order Functions）

### 2.1 什么是高阶函数

高阶函数是接受函数作为参数或返回函数的函数。

```javascript
/**
 * 接受函数作为参数
 */
function map(array, fn) {
  var result = [];
  for (var i = 0; i < array.length; i++) {
    result.push(fn(array[i]));
  }
  return result;
}

var numbers = [1, 2, 3];
var doubled = map(numbers, function(n) {
  return n * 2;
});
console.log(doubled); // [2, 4, 6]

/**
 * 返回函数
 */
function multiply(x) {
  return function(y) {
    return x * y;
  };
}

var double = multiply(2);
console.log(double(5)); // 10
```

### 2.2 数组高阶函数

```javascript
/**
 * map：转换数组元素
 */
var numbers = [1, 2, 3, 4, 5];
var squared = numbers.map(function(n) {
  return n * n;
});
console.log(squared); // [1, 4, 9, 16, 25]

/**
 * filter：过滤数组元素
 */
var numbers = [1, 2, 3, 4, 5, 6];
var evens = numbers.filter(function(n) {
  return n % 2 === 0;
});
console.log(evens); // [2, 4, 6]

/**
 * reduce：累积计算
 */
var numbers = [1, 2, 3, 4, 5];
var sum = numbers.reduce(function(acc, n) {
  return acc + n;
}, 0);
console.log(sum); // 15

// 链式调用
var result = numbers
  .filter(function(n) {
    return n % 2 === 0; // 过滤偶数
  })
  .map(function(n) {
    return n * n; // 平方
  })
  .reduce(function(acc, n) {
    return acc + n; // 求和
  }, 0);
console.log(result); // 20 (2^2 + 4^2 = 4 + 16)

/**
 * forEach：遍历数组（有副作用，非纯函数）
 */
var numbers = [1, 2, 3];
numbers.forEach(function(n) {
  console.log(n);
});

/**
 * find：查找元素
 */
var users = [
  { id: 1, name: "Alice" },
  { id: 2, name: "Bob" },
  { id: 3, name: "Charlie" }
];
var user = users.find(function(u) {
  return u.id === 2;
});
console.log(user); // { id: 2, name: "Bob" }

/**
 * some 和 every：条件检查
 */
var numbers = [2, 4, 6, 8];
var allEven = numbers.every(function(n) {
  return n % 2 === 0;
});
console.log(allEven); // true

var hasOdd = numbers.some(function(n) {
  return n % 2 === 1;
});
console.log(hasOdd); // false
```

## 3. 函数组合（Function Composition）

### 3.1 基础组合

```javascript
/**
 * 函数组合：将多个函数组合成一个函数
 * f(g(x)) = compose(f, g)(x)
 */

function compose(f, g) {
  return function(x) {
    return f(g(x));
  };
}

function add1(x) {
  return x + 1;
}

function multiply2(x) {
  return x * 2;
}

var addThenMultiply = compose(multiply2, add1);
console.log(addThenMultiply(5)); // 12 (5+1)*2

// 多个函数组合
function composeMany() {
  var funcs = Array.prototype.slice.call(arguments);
  return function(x) {
    return funcs.reduceRight(function(acc, fn) {
      return fn(acc);
    }, x);
  };
}

var complex = composeMany(
  multiply2,
  add1,
  multiply2
);
console.log(complex(3)); // 14 ((3*2+1)*2)
```

### 3.2 管道（Pipe）

```javascript
/**
 * 管道：从左到右执行函数（更直观）
 */

function pipe() {
  var funcs = Array.prototype.slice.call(arguments);
  return function(x) {
    return funcs.reduce(function(acc, fn) {
      return fn(acc);
    }, x);
  };
}

var process = pipe(
  function(x) { return x * 2; },
  function(x) { return x + 1; },
  function(x) { return x * 3; }
);
console.log(process(5)); // 33 ((5*2+1)*3)

// ES6 箭头函数版本
var process2 = pipe(
  x => x * 2,
  x => x + 1,
  x => x * 3
);
```

## 4. 柯里化（Currying）

### 4.1 什么是柯里化

柯里化是将多参数函数转换为单参数函数序列的技术。

```javascript
/**
 * 普通函数
 */
function add(a, b, c) {
  return a + b + c;
}

console.log(add(1, 2, 3)); // 6

/**
 * 柯里化版本
 */
function addCurried(a) {
  return function(b) {
    return function(c) {
      return a + b + c;
    };
  };
}

console.log(addCurried(1)(2)(3)); // 6

// 部分应用
var add1 = addCurried(1);
var add1And2 = add1(2);
console.log(add1And2(3)); // 6
```

### 4.2 通用柯里化函数

```javascript
/**
 * 通用柯里化函数
 */
function curry(fn) {
  return function curried() {
    var args = Array.prototype.slice.call(arguments);
    if (args.length >= fn.length) {
      return fn.apply(this, args);
    } else {
      return function() {
        var nextArgs = Array.prototype.slice.call(arguments);
        return curried.apply(this, args.concat(nextArgs));
      };
    }
  };
}

// 使用
function multiply(a, b, c) {
  return a * b * c;
}

var curriedMultiply = curry(multiply);
console.log(curriedMultiply(2)(3)(4));     // 24
console.log(curriedMultiply(2, 3)(4));     // 24
console.log(curriedMultiply(2)(3, 4));     // 24
console.log(curriedMultiply(2, 3, 4));     // 24
```

### 4.3 部分应用（Partial Application）

```javascript
/**
 * 部分应用：预设部分参数
 */
function partial(fn) {
  var presetArgs = Array.prototype.slice.call(arguments, 1);
  return function() {
    var remainingArgs = Array.prototype.slice.call(arguments);
    return fn.apply(this, presetArgs.concat(remainingArgs));
  };
}

function greet(greeting, name, punctuation) {
  return greeting + ", " + name + punctuation;
}

var sayHello = partial(greet, "Hello");
console.log(sayHello("John", "!")); // "Hello, John!"

var sayHelloTo = partial(greet, "Hello", "John");
console.log(sayHelloTo("!")); // "Hello, John!"
```

## 5. 函子（Functors）

### 5.1 Maybe 函子

```javascript
/**
 * Maybe 函子：处理可能为空的值
 */
function Maybe(value) {
  this.value = value;
}

Maybe.prototype.map = function(fn) {
  return this.value == null
    ? Maybe.of(null)
    : Maybe.of(fn(this.value));
};

Maybe.of = function(value) {
  return new Maybe(value);
};

// 使用
var maybe1 = Maybe.of(5);
var result1 = maybe1.map(function(x) {
  return x * 2;
}).map(function(x) {
  return x + 1;
});
console.log(result1.value); // 11

var maybe2 = Maybe.of(null);
var result2 = maybe2.map(function(x) {
  return x * 2; // 不会执行
});
console.log(result2.value); // null（安全处理）
```

### 5.2 Either 函子

```javascript
/**
 * Either 函子：处理可能失败的操作
 */
function Left(value) {
  this.value = value;
}

function Right(value) {
  this.value = value;
}

Left.prototype.map = function(fn) {
  return this; // 不执行函数
};

Right.prototype.map = function(fn) {
  return Right.of(fn(this.value));
};

Right.of = function(value) {
  return new Right(value);
};

Left.of = function(value) {
  return new Left(value);
};

// 使用
function divide(a, b) {
  return b === 0 ? Left.of("除以零") : Right.of(a / b);
}

var result1 = divide(10, 2).map(function(x) {
  return x * 2;
});
console.log(result1.value); // 10

var result2 = divide(10, 0).map(function(x) {
  return x * 2; // 不会执行
});
console.log(result2.value); // "除以零"
```

## 6. 实际应用示例

### 6.1 数据处理管道

```javascript
/**
 * 使用函数式编程处理数据
 */
var users = [
  { name: "Alice", age: 25, active: true },
  { name: "Bob", age: 30, active: false },
  { name: "Charlie", age: 35, active: true },
  { name: "David", age: 20, active: true }
];

// 函数式处理
var activeUsersOver25 = users
  .filter(function(user) {
    return user.active;
  })
  .filter(function(user) {
    return user.age > 25;
  })
  .map(function(user) {
    return user.name;
  });

console.log(activeUsersOver25); // ["Charlie"]

// 使用函数组合
function filterActive(users) {
  return users.filter(function(u) {
    return u.active;
  });
}

function filterAge(minAge) {
  return function(users) {
    return users.filter(function(u) {
      return u.age > minAge;
    });
  };
}

function mapNames(users) {
  return users.map(function(u) {
    return u.name;
  });
}

var processUsers = pipe(
  filterActive,
  filterAge(25),
  mapNames
);

console.log(processUsers(users)); // ["Charlie"]
```

### 6.2 函数式工具库

```javascript
/**
 * 创建函数式工具函数
 */

// 恒等函数
function identity(x) {
  return x;
}

// 常量函数
function constant(x) {
  return function() {
    return x;
  };
}

// 翻转参数
function flip(fn) {
  return function(a, b) {
    return fn(b, a);
  };
}

// 使用
var subtract = function(a, b) {
  return a - b;
};
var flippedSubtract = flip(subtract);
console.log(subtract(5, 3));        // 2
console.log(flippedSubtract(5, 3)); // -2

// 记忆化（Memoization）
function memoize(fn) {
  var cache = {};
  return function() {
    var key = JSON.stringify(arguments);
    if (cache[key]) {
      return cache[key];
    }
    var result = fn.apply(this, arguments);
    cache[key] = result;
    return result;
  };
}

// 使用
var expensiveFunction = memoize(function(n) {
  console.log("计算中...");
  return n * n;
});

console.log(expensiveFunction(5)); // 计算中... 25
console.log(expensiveFunction(5)); // 25（从缓存读取）
```

## 7. 总结

### 关键点：

1. **纯函数**：
   - 相同输入总是产生相同输出
   - 没有副作用
   - 易于测试和推理

2. **不可变性**：
   - 不修改原数据
   - 创建新数据
   - 避免副作用

3. **高阶函数**：
   - 接受函数作为参数
   - 返回函数
   - map、filter、reduce 等

4. **函数组合**：
   - 将小函数组合成大函数
   - compose 和 pipe
   - 提高代码复用性

5. **柯里化**：
   - 多参数函数转单参数函数序列
   - 部分应用
   - 提高函数灵活性

6. **函子**：
   - Maybe：处理空值
   - Either：处理错误
   - 提供安全的函数式操作

7. **最佳实践**：
   - 优先使用纯函数
   - 避免副作用
   - 使用函数组合
   - 利用高阶函数
   - 保持数据不可变

