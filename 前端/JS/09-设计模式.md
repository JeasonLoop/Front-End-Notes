# JavaScript 设计模式

## 1. 设计模式概述

设计模式是解决常见问题的可重用方案。JavaScript 中常用的设计模式包括：

- 创建型：单例、工厂、建造者
- 结构型：适配器、装饰器、代理、外观
- 行为型：观察者、策略、命令、迭代器

## 2. 创建型模式

### 2.1 单例模式（Singleton）

```javascript
/**
 * 单例模式：确保一个类只有一个实例
 * 应用场景：全局配置、数据库连接、日志对象
 */

// 方式1：使用闭包
var Singleton = (function() {
  var instance; // 私有变量，保存唯一实例

  function createInstance() {
    return {
      name: "Singleton Instance",
      getData: function() {
        return "Some data";
      }
    };
  }

  return {
    // 获取单例实例
    getInstance: function() {
      if (!instance) {
        instance = createInstance();
      }
      return instance;
    }
  };
})();

var instance1 = Singleton.getInstance();
var instance2 = Singleton.getInstance();
console.log(instance1 === instance2); // true（同一个实例）

// 方式2：使用 ES6 Class
class SingletonClass {
  constructor() {
    if (SingletonClass.instance) {
      return SingletonClass.instance;
    }
    SingletonClass.instance = this;
    return this;
  }
}

var obj1 = new SingletonClass();
var obj2 = new SingletonClass();
console.log(obj1 === obj2); // true

// 方式3：使用模块模式
var singletonModule = {
  name: "Singleton",
  getData: function() {
    return "Data";
  }
};
// 模块本身就是单例
```

### 2.2 工厂模式（Factory）

```javascript
/**
 * 工厂模式：创建对象而不指定具体类
 * 应用场景：创建复杂对象、根据条件创建不同对象
 */

// 简单工厂
function createAnimal(type) {
  switch (type) {
    case "dog":
      return {
        type: "dog",
        sound: "Woof",
        makeSound: function() {
          console.log(this.sound);
        }
      };
    case "cat":
      return {
        type: "cat",
        sound: "Meow",
        makeSound: function() {
          console.log(this.sound);
        }
      };
    default:
      throw new Error("Unknown animal type");
  }
}

var dog = createAnimal("dog");
dog.makeSound(); // "Woof"

// 工厂方法模式
function AnimalFactory() {}

AnimalFactory.prototype.createAnimal = function(type) {
  throw new Error("Must be implemented by subclass");
};

function DogFactory() {}
DogFactory.prototype = Object.create(AnimalFactory.prototype);
DogFactory.prototype.createAnimal = function() {
  return {
    type: "dog",
    sound: "Woof"
  };
};

function CatFactory() {}
CatFactory.prototype = Object.create(AnimalFactory.prototype);
CatFactory.prototype.createAnimal = function() {
  return {
    type: "cat",
    sound: "Meow"
  };
};

var dogFactory = new DogFactory();
var dog = dogFactory.createAnimal();
console.log(dog.type); // "dog"
```

### 2.3 建造者模式（Builder）

```javascript
/**
 * 建造者模式：分步骤创建复杂对象
 * 应用场景：创建复杂配置对象、SQL 查询构建器
 */

function QueryBuilder() {
  this.query = {
    select: [],
    from: null,
    where: [],
    orderBy: null
  };
}

QueryBuilder.prototype.select = function(fields) {
  this.query.select = Array.isArray(fields) ? fields : [fields];
  return this; // 链式调用
};

QueryBuilder.prototype.from = function(table) {
  this.query.from = table;
  return this;
};

QueryBuilder.prototype.where = function(condition) {
  this.query.where.push(condition);
  return this;
};

QueryBuilder.prototype.orderBy = function(field, direction) {
  this.query.orderBy = { field: field, direction: direction || "ASC" };
  return this;
};

QueryBuilder.prototype.build = function() {
  return this.query;
};

// 使用
var query = new QueryBuilder()
  .select(["name", "age"])
  .from("users")
  .where("age > 18")
  .where("status = 'active'")
  .orderBy("name", "ASC")
  .build();

console.log(query);
```

## 3. 结构型模式

### 3.1 适配器模式（Adapter）

```javascript
/**
 * 适配器模式：让不兼容的接口协同工作
 * 应用场景：集成第三方库、API 适配
 */

// 旧接口
function OldAPI() {
  this.getData = function() {
    return {
      firstName: "John",
      lastName: "Doe",
      age: 30
    };
  };
}

// 新接口需要的格式
function NewAPI() {
  this.getUser = function() {
    return {
      name: "John Doe",
      age: 30
    };
  };
}

// 适配器
function APIAdapter(oldAPI) {
  this.oldAPI = oldAPI;

  this.getUser = function() {
    var data = this.oldAPI.getData();
    return {
      name: data.firstName + " " + data.lastName,
      age: data.age
    };
  };
}

// 使用
var oldAPI = new OldAPI();
var adapter = new APIAdapter(oldAPI);
var user = adapter.getUser();
console.log(user); // { name: "John Doe", age: 30 }
```

### 3.2 装饰器模式（Decorator）

```javascript
/**
 * 装饰器模式：动态添加功能
 * 应用场景：功能增强、中间件
 */

// 基础组件
function Coffee() {
  this.cost = function() {
    return 5;
  };
  this.description = function() {
    return "Coffee";
  };
}

// 装饰器基类
function CoffeeDecorator(coffee) {
  this.coffee = coffee;
}

CoffeeDecorator.prototype.cost = function() {
  return this.coffee.cost();
};

CoffeeDecorator.prototype.description = function() {
  return this.coffee.description();
};

// 具体装饰器
function Milk(coffee) {
  CoffeeDecorator.call(this, coffee);
}

Milk.prototype = Object.create(CoffeeDecorator.prototype);
Milk.prototype.cost = function() {
  return this.coffee.cost() + 2;
};
Milk.prototype.description = function() {
  return this.coffee.description() + ", Milk";
};

function Sugar(coffee) {
  CoffeeDecorator.call(this, coffee);
}

Sugar.prototype = Object.create(CoffeeDecorator.prototype);
Sugar.prototype.cost = function() {
  return this.coffee.cost() + 1;
};
Sugar.prototype.description = function() {
  return this.coffee.description() + ", Sugar";
};

// 使用
var coffee = new Coffee();
var coffeeWithMilk = new Milk(coffee);
var coffeeWithMilkAndSugar = new Sugar(coffeeWithMilk);

console.log(coffeeWithMilkAndSugar.description()); // "Coffee, Milk, Sugar"
console.log(coffeeWithMilkAndSugar.cost()); // 8
```

### 3.3 代理模式（Proxy）

```javascript
/**
 * 代理模式：为对象提供代理以控制访问
 * 应用场景：虚拟代理、保护代理、缓存代理
 */

// 真实对象
function RealImage(filename) {
  this.filename = filename;
  this.loadFromDisk();
}

RealImage.prototype.loadFromDisk = function() {
  console.log("Loading " + this.filename);
};

RealImage.prototype.display = function() {
  console.log("Displaying " + this.filename);
};

// 代理对象
function ProxyImage(filename) {
  this.filename = filename;
  this.realImage = null;
}

ProxyImage.prototype.display = function() {
  // 延迟加载：只在需要时创建真实对象
  if (!this.realImage) {
    this.realImage = new RealImage(this.filename);
  }
  this.realImage.display();
};

// 使用
var image = new ProxyImage("photo.jpg");
// 此时还没有加载图片
image.display(); // 现在才加载并显示
```

### 3.4 外观模式（Facade）

```javascript
/**
 * 外观模式：提供简化的接口
 * 应用场景：简化复杂子系统、统一接口
 */

// 复杂子系统
function CPU() {
  this.start = function() {
    console.log("CPU started");
  };
}

function Memory() {
  this.load = function() {
    console.log("Memory loaded");
  };
}

function HardDrive() {
  this.read = function() {
    console.log("Hard drive read");
  };
}

// 外观：简化接口
function Computer() {
  this.cpu = new CPU();
  this.memory = new Memory();
  this.hardDrive = new HardDrive();
}

Computer.prototype.start = function() {
  this.cpu.start();
  this.memory.load();
  this.hardDrive.read();
  console.log("Computer started");
};

// 使用：客户端只需要调用简单接口
var computer = new Computer();
computer.start();
// 输出：
// CPU started
// Memory loaded
// Hard drive read
// Computer started
```

## 4. 行为型模式

### 4.1 观察者模式（Observer）

```javascript
/**
 * 观察者模式：对象间一对多依赖关系
 * 应用场景：事件系统、MVC 架构、发布订阅
 */

// 主题（被观察者）
function Subject() {
  this.observers = [];
}

Subject.prototype.addObserver = function(observer) {
  this.observers.push(observer);
};

Subject.prototype.removeObserver = function(observer) {
  var index = this.observers.indexOf(observer);
  if (index > -1) {
    this.observers.splice(index, 1);
  }
};

Subject.prototype.notify = function(data) {
  this.observers.forEach(function(observer) {
    observer.update(data);
  });
};

// 观察者
function Observer(name) {
  this.name = name;
}

Observer.prototype.update = function(data) {
  console.log(this.name + " received: " + data);
};

// 使用
var subject = new Subject();
var observer1 = new Observer("Observer 1");
var observer2 = new Observer("Observer 2");

subject.addObserver(observer1);
subject.addObserver(observer2);

subject.notify("Hello");
// 输出：
// Observer 1 received: Hello
// Observer 2 received: Hello
```

### 4.2 策略模式（Strategy）

```javascript
/**
 * 策略模式：定义算法族，使它们可以互换
 * 应用场景：多种算法选择、表单验证
 */

// 策略接口
var PaymentStrategy = {
  pay: function(amount) {
    throw new Error("Must be implemented");
  }
};

// 具体策略
var CreditCardStrategy = {
  pay: function(amount) {
    console.log("Paid $" + amount + " using Credit Card");
  }
};

var PayPalStrategy = {
  pay: function(amount) {
    console.log("Paid $" + amount + " using PayPal");
  }
};

var BitcoinStrategy = {
  pay: function(amount) {
    console.log("Paid $" + amount + " using Bitcoin");
  }
};

// 上下文
function PaymentProcessor() {
  this.strategy = null;
}

PaymentProcessor.prototype.setStrategy = function(strategy) {
  this.strategy = strategy;
};

PaymentProcessor.prototype.processPayment = function(amount) {
  if (!this.strategy) {
    throw new Error("Payment strategy not set");
  }
  this.strategy.pay(amount);
};

// 使用
var processor = new PaymentProcessor();
processor.setStrategy(CreditCardStrategy);
processor.processPayment(100); // "Paid $100 using Credit Card"

processor.setStrategy(PayPalStrategy);
processor.processPayment(200); // "Paid $200 using PayPal"
```

### 4.3 命令模式（Command）

```javascript
/**
 * 命令模式：将请求封装为对象
 * 应用场景：撤销/重做、队列请求、日志记录
 */

// 命令接口
function Command() {
  this.execute = function() {
    throw new Error("Must be implemented");
  };
  this.undo = function() {
    throw new Error("Must be implemented");
  };
}

// 接收者
function Light() {
  this.on = false;
}

Light.prototype.turnOn = function() {
  this.on = true;
  console.log("Light is ON");
};

Light.prototype.turnOff = function() {
  this.on = false;
  console.log("Light is OFF");
};

// 具体命令
function LightOnCommand(light) {
  this.light = light;
}

LightOnCommand.prototype = Object.create(Command.prototype);
LightOnCommand.prototype.execute = function() {
  this.light.turnOn();
};
LightOnCommand.prototype.undo = function() {
  this.light.turnOff();
};

function LightOffCommand(light) {
  this.light = light;
}

LightOffCommand.prototype = Object.create(Command.prototype);
LightOffCommand.prototype.execute = function() {
  this.light.turnOff();
};
LightOffCommand.prototype.undo = function() {
  this.light.turnOn();
};

// 调用者
function RemoteControl() {
  this.command = null;
  this.history = [];
}

RemoteControl.prototype.setCommand = function(command) {
  this.command = command;
};

RemoteControl.prototype.pressButton = function() {
  if (this.command) {
    this.command.execute();
    this.history.push(this.command);
  }
};

RemoteControl.prototype.pressUndo = function() {
  if (this.history.length > 0) {
    var lastCommand = this.history.pop();
    lastCommand.undo();
  }
};

// 使用
var light = new Light();
var lightOn = new LightOnCommand(light);
var lightOff = new LightOffCommand(light);

var remote = new RemoteControl();
remote.setCommand(lightOn);
remote.pressButton(); // "Light is ON"
remote.pressUndo();   // "Light is OFF"
```

### 4.4 迭代器模式（Iterator）

```javascript
/**
 * 迭代器模式：提供遍历集合的统一接口
 * JavaScript 内置支持（Symbol.iterator）
 */

// 自定义迭代器
function NumberRange(start, end) {
  this.start = start;
  this.end = end;
}

NumberRange.prototype[Symbol.iterator] = function() {
  var current = this.start;
  var end = this.end;

  return {
    next: function() {
      if (current <= end) {
        return { value: current++, done: false };
      }
      return { done: true };
    }
  };
};

// 使用
var range = new NumberRange(1, 5);
for (var num of range) {
  console.log(num); // 1, 2, 3, 4, 5
}

console.log([...range]); // [1, 2, 3, 4, 5]
```

## 5. 模块模式

### 5.1 模块模式

```javascript
/**
 * 模块模式：创建私有作用域，暴露公共接口
 * 应用场景：命名空间、代码组织
 */

var MyModule = (function() {
  // 私有变量
  var privateVar = "I am private";

  // 私有函数
  function privateFunction() {
    console.log("Private function");
  }

  // 返回公共接口
  return {
    // 公共方法
    publicMethod: function() {
      console.log("Public method");
      privateFunction(); // 可以访问私有函数
    },
    // 公共变量
    publicVar: "I am public",
    // 访问私有变量的方法
    getPrivateVar: function() {
      return privateVar;
    }
  };
})();

MyModule.publicMethod();        // "Public method" 和 "Private function"
console.log(MyModule.publicVar); // "I am public"
console.log(MyModule.getPrivateVar()); // "I am private"
// MyModule.privateFunction();  // 报错：无法访问
```

## 6. 总结

### 设计模式选择：

1. **创建型**：
   - 单例：需要唯一实例
   - 工厂：创建复杂对象
   - 建造者：分步构建对象

2. **结构型**：
   - 适配器：接口不兼容
   - 装饰器：动态添加功能
   - 代理：控制对象访问
   - 外观：简化接口

3. **行为型**：
   - 观察者：一对多依赖
   - 策略：算法选择
   - 命令：请求封装
   - 迭代器：遍历集合

### 最佳实践：

- 不要过度设计
- 理解模式意图
- 根据实际需求选择
- 保持代码简洁
- 优先使用语言特性（如 ES6+）

设计模式是工具，不是目标。理解问题本质，选择合适方案。

