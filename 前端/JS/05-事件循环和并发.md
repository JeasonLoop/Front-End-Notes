# JavaScript 事件循环和并发

## 1. JavaScript 执行模型

### 1.1 单线程模型

```javascript
/**
 * JavaScript 是单线程的，同一时间只能执行一个任务
 * 这意味着代码是顺序执行的，不会出现真正的并行
 */

console.log("1");
console.log("2");
console.log("3");
// 输出：1 2 3（顺序执行）

// 即使有异步操作，也是顺序执行的
console.log("开始");
setTimeout(function() {
  console.log("异步");
}, 0);
console.log("结束");
// 输出：开始 -> 结束 -> 异步（异步操作在同步代码之后执行）
```

### 1.2 调用栈（Call Stack）

```javascript
/**
 * 调用栈：存储函数调用的栈结构
 * 后进先出（LIFO）
 */

function a() {
  console.log("a");
  b();
}

function b() {
  console.log("b");
  c();
}

function c() {
  console.log("c");
}

a();
// 调用栈：a -> b -> c
// 执行顺序：a -> b -> c
// 输出：a b c
```

## 2. 事件循环（Event Loop）

### 2.1 事件循环机制

```javascript
/**
 * 事件循环是 JavaScript 处理异步操作的机制
 * 包含：调用栈、消息队列、微任务队列
 */

console.log("1");

setTimeout(function() {
  console.log("2");
}, 0);

Promise.resolve().then(function() {
  console.log("3");
});

console.log("4");

// 输出：1 4 3 2
// 执行顺序：
// 1. 同步代码：1, 4
// 2. 微任务：3
// 3. 宏任务：2
```

### 2.2 宏任务（Macro Task）

```javascript
/**
 * 宏任务：setTimeout、setInterval、I/O 操作、UI 渲染等
 * 每次事件循环只处理一个宏任务
 */

console.log("开始");

setTimeout(function() {
  console.log("宏任务 1");
}, 0);

setTimeout(function() {
  console.log("宏任务 2");
}, 0);

console.log("结束");

// 输出：开始 -> 结束 -> 宏任务 1 -> 宏任务 2
```

### 2.3 微任务（Micro Task）

```javascript
/**
 * 微任务：Promise.then、queueMicrotask、MutationObserver
 * 微任务在当前宏任务执行完后立即执行，优先级高于宏任务
 */

console.log("1");

setTimeout(function() {
  console.log("2");
}, 0);

Promise.resolve().then(function() {
  console.log("3");
  return Promise.resolve();
}).then(function() {
  console.log("4");
});

console.log("5");

// 输出：1 5 3 4 2
// 执行顺序：
// 1. 同步代码：1, 5
// 2. 微任务队列：3, 4（所有微任务执行完）
// 3. 宏任务：2
```

### 2.4 执行顺序总结

```javascript
/**
 * 执行顺序：
 * 1. 同步代码
 * 2. 微任务队列（全部执行完）
 * 3. 宏任务队列（每次执行一个）
 * 4. 重复步骤 2-3
 */

console.log("同步 1");

setTimeout(function() {
  console.log("宏任务 1");
}, 0);

Promise.resolve().then(function() {
  console.log("微任务 1");

  setTimeout(function() {
    console.log("宏任务 2");
  }, 0);

  Promise.resolve().then(function() {
    console.log("微任务 2");
  });
});

console.log("同步 2");

// 输出：
// 同步 1
// 同步 2
// 微任务 1
// 微任务 2
// 宏任务 1
// 宏任务 2
```

## 3. 异步操作详解

### 3.1 setTimeout 和 setInterval

```javascript
/**
 * setTimeout：延迟执行
 * setInterval：定时重复执行
 */

// setTimeout
var timer1 = setTimeout(function() {
  console.log("延迟 1 秒");
}, 1000);

// 清除定时器
clearTimeout(timer1);

// setInterval
var timer2 = setInterval(function() {
  console.log("每秒执行");
}, 1000);

// 清除定时器
setTimeout(function() {
  clearInterval(timer2);
}, 5000);

// 注意：setTimeout 的最小延迟时间
setTimeout(function() {
  console.log("立即执行？");
}, 0);
// 实际上不会立即执行，最小延迟约 4ms（浏览器限制）
```

### 3.2 Promise 的执行时机

```javascript
/**
 * Promise 的 then 回调是微任务
 */

console.log("1");

new Promise(function(resolve) {
  console.log("2"); // 同步执行
  resolve();
}).then(function() {
  console.log("3"); // 微任务
});

console.log("4");

// 输出：1 2 4 3
```

### 3.3 async/await 的执行

```javascript
/**
 * async/await 本质是 Promise 的语法糖
 * await 后面的代码相当于 then 回调（微任务）
 */

async function async1() {
  console.log("async1 开始");
  await async2();
  console.log("async1 结束"); // 微任务
}

async function async2() {
  console.log("async2");
}

console.log("script 开始");

setTimeout(function() {
  console.log("setTimeout");
}, 0);

async1();

new Promise(function(resolve) {
  console.log("promise1");
  resolve();
}).then(function() {
  console.log("promise2");
});

console.log("script 结束");

// 输出：
// script 开始
// async1 开始
// async2
// promise1
// script 结束
// async1 结束
// promise2
// setTimeout
```

## 4. 并发和并行

### 4.1 Web Workers（真正的并行）

```javascript
/**
 * Web Workers 允许在后台线程运行脚本
 * 实现真正的并行执行
 */

// 主线程：main.js
var worker = new Worker("worker.js");

// 发送消息给 Worker
worker.postMessage({ command: "start", data: 1000000 });

// 接收 Worker 的消息
worker.onmessage = function(event) {
  console.log("收到结果：", event.data);
};

// Worker 线程：worker.js
self.onmessage = function(event) {
  var data = event.data;

  // 执行耗时操作
  var result = 0;
  for (var i = 0; i < data.data; i++) {
    result += i;
  }

  // 发送结果回主线程
  self.postMessage({ result: result });
};

// 终止 Worker
worker.terminate();
```

### 4.2 并发控制

```javascript
/**
 * 控制并发数量，避免同时执行太多异步操作
 */

// 并发控制函数
async function limitConcurrency(tasks, limit) {
  var results = [];
  var executing = [];

  for (var i = 0; i < tasks.length; i++) {
    var task = tasks[i];

    // 创建 Promise
    var promise = Promise.resolve().then(function() {
      return task();
    });

    results.push(promise);

    // 如果达到限制，等待一个完成
    if (limit <= tasks.length) {
      var e = promise.then(function() {
        executing.splice(executing.indexOf(e), 1);
      });
      executing.push(e);

      if (executing.length >= limit) {
        await Promise.race(executing);
      }
    }
  }

  return Promise.all(results);
}

// 使用示例
var tasks = [
  function() { return fetch("/api/1"); },
  function() { return fetch("/api/2"); },
  function() { return fetch("/api/3"); },
  function() { return fetch("/api/4"); },
  function() { return fetch("/api/5"); }
];

limitConcurrency(tasks, 2); // 最多同时 2 个请求
```

## 5. 性能优化

### 5.1 避免阻塞主线程

```javascript
/**
 * 长时间运行的任务会阻塞主线程
 * 使用 setTimeout 或 requestIdleCallback 分片执行
 */

// 阻塞主线程的代码
function blockingTask() {
  for (var i = 0; i < 10000000; i++) {
    // 耗时操作
  }
}

// 分片执行（使用 setTimeout）
function nonBlockingTask(items, callback) {
  var index = 0;

  function processChunk() {
    var chunkSize = 1000;
    var end = Math.min(index + chunkSize, items.length);

    for (var i = index; i < end; i++) {
      // 处理每个项目
      processItem(items[i]);
    }

    index = end;

    if (index < items.length) {
      // 让出控制权，允许其他任务执行
      setTimeout(processChunk, 0);
    } else {
      callback();
    }
  }

  processChunk();
}

// 使用 requestIdleCallback（浏览器）
function processWithIdleCallback(items, callback) {
  var index = 0;

  function processChunk(deadline) {
    while (deadline.timeRemaining() > 0 && index < items.length) {
      processItem(items[index]);
      index++;
    }

    if (index < items.length) {
      requestIdleCallback(processChunk);
    } else {
      callback();
    }
  }

  requestIdleCallback(processChunk);
}
```

### 5.2 防抖和节流

```javascript
/**
 * 防抖（Debounce）：延迟执行，如果再次触发则重新计时
 * 节流（Throttle）：限制执行频率
 */

// 防抖
function debounce(func, wait) {
  var timeout;
  return function() {
    var context = this;
    var args = arguments;
    clearTimeout(timeout);
    timeout = setTimeout(function() {
      func.apply(context, args);
    }, wait);
  };
}

// 节流
function throttle(func, wait) {
  var lastTime = 0;
  return function() {
    var context = this;
    var args = arguments;
    var now = Date.now();
    if (now - lastTime >= wait) {
      lastTime = now;
      func.apply(context, args);
    }
  };
}

// 使用示例
var searchInput = document.getElementById("search");
var debouncedSearch = debounce(function(query) {
  console.log("搜索：", query);
}, 300);

searchInput.addEventListener("input", function(e) {
  debouncedSearch(e.target.value);
});

var scrollHandler = throttle(function() {
  console.log("滚动");
}, 200);

window.addEventListener("scroll", scrollHandler);
```

## 6. 实际应用示例

### 6.1 异步队列

```javascript
/**
 * 实现异步任务队列
 */

class AsyncQueue {
  constructor() {
    this.queue = [];
    this.processing = false;
  }

  // 添加任务
  enqueue(task) {
    return new Promise(function(resolve, reject) {
      this.queue.push({
        task: task,
        resolve: resolve,
        reject: reject
      });
      this.process();
    }.bind(this));
  }

  // 处理队列
  async process() {
    if (this.processing || this.queue.length === 0) {
      return;
    }

    this.processing = true;

    while (this.queue.length > 0) {
      var item = this.queue.shift();
      try {
        var result = await item.task();
        item.resolve(result);
      } catch (error) {
        item.reject(error);
      }
    }

    this.processing = false;
  }
}

// 使用
var queue = new AsyncQueue();

queue.enqueue(function() {
  return Promise.resolve("任务 1");
}).then(function(result) {
  console.log(result);
});

queue.enqueue(function() {
  return Promise.resolve("任务 2");
}).then(function(result) {
  console.log(result);
});
```

### 6.2 批量处理

```javascript
/**
 * 批量处理数据，避免一次性处理太多
 */

async function batchProcess(items, processor, batchSize = 10) {
  var results = [];

  for (var i = 0; i < items.length; i += batchSize) {
    var batch = items.slice(i, i + batchSize);
    var batchResults = await Promise.all(
      batch.map(function(item) {
        return processor(item);
      })
    );
    results.push.apply(results, batchResults);

    // 让出控制权
    await new Promise(function(resolve) {
      setTimeout(resolve, 0);
    });
  }

  return results;
}

// 使用
var items = Array.from({ length: 100 }, function(_, i) {
  return i;
});

batchProcess(items, function(item) {
  return Promise.resolve(item * 2);
}, 10).then(function(results) {
  console.log(results);
});
```

## 7. 总结

### 关键点：

1. **事件循环**：
   - 单线程执行模型
   - 调用栈、消息队列、微任务队列
   - 执行顺序：同步代码 -> 微任务 -> 宏任务

2. **任务类型**：
   - 宏任务：setTimeout、setInterval、I/O
   - 微任务：Promise.then、queueMicrotask

3. **并发控制**：
   - Web Workers 实现真正的并行
   - 控制并发数量避免过载
   - 分片处理长时间任务

4. **性能优化**：
   - 避免阻塞主线程
   - 使用防抖和节流
   - 批量处理数据

5. **最佳实践**：
   - 理解事件循环机制
   - 合理使用异步操作
   - 注意性能影响
   - 控制并发数量

